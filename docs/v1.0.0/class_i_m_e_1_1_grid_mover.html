<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>IME - Infinite Motion Engine</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="ime">Documentation of IME 1.0.0</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.20 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_i_m_e.html">IME</a></li><li class="navelem"><a class="el" href="class_i_m_e_1_1_grid_mover.html">GridMover</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_i_m_e_1_1_grid_mover-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">IME::GridMover Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for performing grid based movement on an entity in a grid.  
 <a href="class_i_m_e_1_1_grid_mover.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for IME::GridMover:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_i_m_e_1_1_grid_mover.png" usemap="#IME::GridMover_map" alt=""/>
  <map id="IME::GridMover_map" name="IME::GridMover_map">
<area href="class_i_m_e_1_1_keyboard_controlled_grid_mover.html" title="Class that performs grid based movement on an entity using the keyboard as a movement trigger." alt="IME::KeyboardControlledGridMover" shape="rect" coords="0,56,214,80"/>
<area href="class_i_m_e_1_1_random_grid_mover.html" title="Class for moving an entity randomly in a grid." alt="IME::RandomGridMover" shape="rect" coords="224,56,438,80"/>
<area href="class_i_m_e_1_1_target_grid_mover.html" title="Class for moving an entity to a specific position in the grid." alt="IME::TargetGridMover" shape="rect" coords="448,56,662,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afce67fd4584edd1782b28d3158f51e89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> = std::shared_ptr&lt; <a class="el" href="class_i_m_e_1_1_entity.html">Entity</a> &gt;</td></tr>
<tr class="memdesc:afce67fd4584edd1782b28d3158f51e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="class_i_m_e_1_1_entity.html" title="Abstract base class for all game entities (players, enemies etc...)">Entity</a> alias.  <a href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">More...</a><br /></td></tr>
<tr class="separator:afce67fd4584edd1782b28d3158f51e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4780784c1daab7df00f70cbf13cf2951"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a4780784c1daab7df00f70cbf13cf2951">GridMover</a> (<a class="el" href="class_i_m_e_1_1_tile_map.html">TileMap</a> &amp;tileMap, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> target)</td></tr>
<tr class="memdesc:a4780784c1daab7df00f70cbf13cf2951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a grid mover.  <a href="class_i_m_e_1_1_grid_mover.html#a4780784c1daab7df00f70cbf13cf2951">More...</a><br /></td></tr>
<tr class="separator:a4780784c1daab7df00f70cbf13cf2951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0593390e3b9ff4c1dcfad0e6f67b38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a7c0593390e3b9ff4c1dcfad0e6f67b38">requestDirectionChange</a> (<a class="el" href="namespace_i_m_e.html#a049571570caab5e6dc75bf2075e5e89f">Direction</a> newDir)</td></tr>
<tr class="memdesc:a7c0593390e3b9ff4c1dcfad0e6f67b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the direction of the target entity.  <a href="class_i_m_e_1_1_grid_mover.html#a7c0593390e3b9ff4c1dcfad0e6f67b38">More...</a><br /></td></tr>
<tr class="separator:a7c0593390e3b9ff4c1dcfad0e6f67b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340c637dfdb14515499cbd4efe087b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a340c637dfdb14515499cbd4efe087b54">setTarget</a> (<a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> target)</td></tr>
<tr class="memdesc:a340c637dfdb14515499cbd4efe087b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the controlled entity.  <a href="class_i_m_e_1_1_grid_mover.html#a340c637dfdb14515499cbd4efe087b54">More...</a><br /></td></tr>
<tr class="separator:a340c637dfdb14515499cbd4efe087b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7297d4a7e1f2ba86015f21b1e7999aa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a7297d4a7e1f2ba86015f21b1e7999aa6">getTarget</a> () const</td></tr>
<tr class="memdesc:a7297d4a7e1f2ba86015f21b1e7999aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the controlled entity.  <a href="class_i_m_e_1_1_grid_mover.html#a7297d4a7e1f2ba86015f21b1e7999aa6">More...</a><br /></td></tr>
<tr class="separator:a7297d4a7e1f2ba86015f21b1e7999aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5ecd6b0e1786704bed4000e17796e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_m_e_1_1_tile_map.html">TileMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a1e5ecd6b0e1786704bed4000e17796e2">getGrid</a> ()</td></tr>
<tr class="memdesc:a1e5ecd6b0e1786704bed4000e17796e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the grid in which the target is moved in.  <a href="class_i_m_e_1_1_grid_mover.html#a1e5ecd6b0e1786704bed4000e17796e2">More...</a><br /></td></tr>
<tr class="separator:a1e5ecd6b0e1786704bed4000e17796e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4330bdd82d9261570e3f427a77bb367d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a4330bdd82d9261570e3f427a77bb367d">isTargetMoving</a> () const</td></tr>
<tr class="memdesc:a4330bdd82d9261570e3f427a77bb367d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if target is moving or not.  <a href="class_i_m_e_1_1_grid_mover.html#a4330bdd82d9261570e3f427a77bb367d">More...</a><br /></td></tr>
<tr class="separator:a4330bdd82d9261570e3f427a77bb367d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f3a2739ea58753defeab33b7e1c59a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a89f3a2739ea58753defeab33b7e1c59a">update</a> (float deltaTime)</td></tr>
<tr class="memdesc:a89f3a2739ea58753defeab33b7e1c59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update entity movement in the grid.  <a href="class_i_m_e_1_1_grid_mover.html#a89f3a2739ea58753defeab33b7e1c59a">More...</a><br /></td></tr>
<tr class="separator:a89f3a2739ea58753defeab33b7e1c59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0657c8c12c14a02025f3ab7fbbe62647"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a0657c8c12c14a02025f3ab7fbbe62647">teleportTargetToDestination</a> ()</td></tr>
<tr class="memdesc:a0657c8c12c14a02025f3ab7fbbe62647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the target to reach it's destination.  <a href="class_i_m_e_1_1_grid_mover.html#a0657c8c12c14a02025f3ab7fbbe62647">More...</a><br /></td></tr>
<tr class="separator:a0657c8c12c14a02025f3ab7fbbe62647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39df9a6e65753c590c1d8fff48d2eb49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a39df9a6e65753c590c1d8fff48d2eb49">onTargetChanged</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt; callback)</td></tr>
<tr class="memdesc:a39df9a6e65753c590c1d8fff48d2eb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a target change event.  <a href="class_i_m_e_1_1_grid_mover.html#a39df9a6e65753c590c1d8fff48d2eb49">More...</a><br /></td></tr>
<tr class="separator:a39df9a6e65753c590c1d8fff48d2eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4ef7952bf3d8a5d2fcd69a020cf02c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a9a4ef7952bf3d8a5d2fcd69a020cf02c">onAdjacentTileReached</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_graphics_1_1_tile.html">Graphics::Tile</a> &gt; callback)</td></tr>
<tr class="memdesc:a9a4ef7952bf3d8a5d2fcd69a020cf02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an adjacent tile reached event.  <a href="class_i_m_e_1_1_grid_mover.html#a9a4ef7952bf3d8a5d2fcd69a020cf02c">More...</a><br /></td></tr>
<tr class="separator:a9a4ef7952bf3d8a5d2fcd69a020cf02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72560ff0adf75480ee1b763d26abaa18"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a72560ff0adf75480ee1b763d26abaa18">onGridBorderCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt;&gt; callback)</td></tr>
<tr class="memdesc:a72560ff0adf75480ee1b763d26abaa18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a tilemap border collision event.  <a href="class_i_m_e_1_1_grid_mover.html#a72560ff0adf75480ee1b763d26abaa18">More...</a><br /></td></tr>
<tr class="separator:a72560ff0adf75480ee1b763d26abaa18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6547008f49425fa4876c24cb53b249ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a6547008f49425fa4876c24cb53b249ca">onSolidTileCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_graphics_1_1_tile.html">IME::Graphics::Tile</a> &gt; callback)</td></tr>
<tr class="memdesc:a6547008f49425fa4876c24cb53b249ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a tile collision event.  <a href="class_i_m_e_1_1_grid_mover.html#a6547008f49425fa4876c24cb53b249ca">More...</a><br /></td></tr>
<tr class="separator:a6547008f49425fa4876c24cb53b249ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd209b1bd94f6f62d75c62ef8dde9ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a1fd209b1bd94f6f62d75c62ef8dde9ff">onObstacleCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt; callback)</td></tr>
<tr class="memdesc:a1fd209b1bd94f6f62d75c62ef8dde9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an obstacle collision.  <a href="class_i_m_e_1_1_grid_mover.html#a1fd209b1bd94f6f62d75c62ef8dde9ff">More...</a><br /></td></tr>
<tr class="separator:a1fd209b1bd94f6f62d75c62ef8dde9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fd836eaa9c7155fd201bc9d643b117"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a58fd836eaa9c7155fd201bc9d643b117">onCollectableCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt; callback)</td></tr>
<tr class="memdesc:a58fd836eaa9c7155fd201bc9d643b117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a collectable collision event.  <a href="class_i_m_e_1_1_grid_mover.html#a58fd836eaa9c7155fd201bc9d643b117">More...</a><br /></td></tr>
<tr class="separator:a58fd836eaa9c7155fd201bc9d643b117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2123d1fb1ec74b3d316af6f94e2e28c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a2123d1fb1ec74b3d316af6f94e2e28c3">onEnemyCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt; callback)</td></tr>
<tr class="memdesc:a2123d1fb1ec74b3d316af6f94e2e28c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an enemy collision event.  <a href="class_i_m_e_1_1_grid_mover.html#a2123d1fb1ec74b3d316af6f94e2e28c3">More...</a><br /></td></tr>
<tr class="separator:a2123d1fb1ec74b3d316af6f94e2e28c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700278dce7fa07c91429de507aea9ba2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a700278dce7fa07c91429de507aea9ba2">onPlayerCollision</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt; callback)</td></tr>
<tr class="memdesc:a700278dce7fa07c91429de507aea9ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a player collision event.  <a href="class_i_m_e_1_1_grid_mover.html#a700278dce7fa07c91429de507aea9ba2">More...</a><br /></td></tr>
<tr class="separator:a700278dce7fa07c91429de507aea9ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186e70c1466d4f91619007d424705e3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a186e70c1466d4f91619007d424705e3e">removeCollisionHandler</a> (int handlerId)</td></tr>
<tr class="memdesc:a186e70c1466d4f91619007d424705e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an external collision handler.  <a href="class_i_m_e_1_1_grid_mover.html#a186e70c1466d4f91619007d424705e3e">More...</a><br /></td></tr>
<tr class="separator:a186e70c1466d4f91619007d424705e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae61f484b45612947b3ac0936a55c81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#acae61f484b45612947b3ac0936a55c81">removeInternalCollisionHandlerFor</a> (const std::string &amp;handler)</td></tr>
<tr class="memdesc:acae61f484b45612947b3ac0936a55c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the internal handler for a given collision event.  <a href="class_i_m_e_1_1_grid_mover.html#acae61f484b45612947b3ac0936a55c81">More...</a><br /></td></tr>
<tr class="separator:acae61f484b45612947b3ac0936a55c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50101bf347ecd0813cc3a99cd9ef5e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#ab50101bf347ecd0813cc3a99cd9ef5e5">isInternalHandlerRemoved</a> (const std::string &amp;handler)</td></tr>
<tr class="memdesc:ab50101bf347ecd0813cc3a99cd9ef5e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the internal collision handler is removed or not.  <a href="class_i_m_e_1_1_grid_mover.html#ab50101bf347ecd0813cc3a99cd9ef5e5">More...</a><br /></td></tr>
<tr class="separator:ab50101bf347ecd0813cc3a99cd9ef5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735bf44b6390c05ca3ec5909218a3568"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a735bf44b6390c05ca3ec5909218a3568">~GridMover</a> ()=default</td></tr>
<tr class="memdesc:a735bf44b6390c05ca3ec5909218a3568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="class_i_m_e_1_1_grid_mover.html#a735bf44b6390c05ca3ec5909218a3568">More...</a><br /></td></tr>
<tr class="separator:a735bf44b6390c05ca3ec5909218a3568"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a51ca1051448423e2ad9fc91279c56d24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_i_m_e_1_1_grid_mover.html#a51ca1051448423e2ad9fc91279c56d24">onInternalHandlerRemove</a> (<a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; std::string &gt; callback)</td></tr>
<tr class="memdesc:a51ca1051448423e2ad9fc91279c56d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a callback when an internal handler is removed.  <a href="class_i_m_e_1_1_grid_mover.html#a51ca1051448423e2ad9fc91279c56d24">More...</a><br /></td></tr>
<tr class="separator:a51ca1051448423e2ad9fc91279c56d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for performing grid based movement on an entity in a grid. </p>
<p>This class monitors the movement of an entity in a grid and ensures that it always moves from one cell to the next and never between grid cells. The entities direction cannot be changed until it has completed it's current movement </p>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00042">42</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afce67fd4584edd1782b28d3158f51e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce67fd4584edd1782b28d3158f51e89">&#9670;&nbsp;</a></span>EntityPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">IME::GridMover::EntityPtr</a> =  std::shared_ptr&lt;<a class="el" href="class_i_m_e_1_1_entity.html">Entity</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to <a class="el" href="class_i_m_e_1_1_entity.html" title="Abstract base class for all game entities (players, enemies etc...)">Entity</a> alias. </p>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00044">44</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4780784c1daab7df00f70cbf13cf2951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4780784c1daab7df00f70cbf13cf2951">&#9670;&nbsp;</a></span>GridMover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IME::GridMover::GridMover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_m_e_1_1_tile_map.html">TileMap</a> &amp;&#160;</td>
          <td class="paramname"><em>tileMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a grid mover. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tileMap</td><td>Grid to move a target entity in </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="class_i_m_e_1_1_entity.html" title="Abstract base class for all game entities (players, enemies etc...)">Entity</a> to be moved in the grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>if the target is not a nullptr, then it must be placed in the grid prior to instantiation of this class </dd></dl>

</div>
</div>
<a id="a735bf44b6390c05ca3ec5909218a3568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735bf44b6390c05ca3ec5909218a3568">&#9670;&nbsp;</a></span>~GridMover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IME::GridMover::~GridMover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1e5ecd6b0e1786704bed4000e17796e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5ecd6b0e1786704bed4000e17796e2">&#9670;&nbsp;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_m_e_1_1_tile_map.html">TileMap</a>&amp; IME::GridMover::getGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the grid in which the target is moved in. </p>
<dl class="section return"><dt>Returns</dt><dd>The grid in which the target is being moved in </dd></dl>

</div>
</div>
<a id="a7297d4a7e1f2ba86015f21b1e7999aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7297d4a7e1f2ba86015f21b1e7999aa6">&#9670;&nbsp;</a></span>getTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> IME::GridMover::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the controlled entity. </p>
<dl class="section return"><dt>Returns</dt><dd>The controlled entity, or a nullptr if there is no entity to control </dd></dl>

</div>
</div>
<a id="ab50101bf347ecd0813cc3a99cd9ef5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50101bf347ecd0813cc3a99cd9ef5e5">&#9670;&nbsp;</a></span>isInternalHandlerRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IME::GridMover::isInternalHandlerRemoved </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the internal collision handler is removed or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Name of the handler to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the handler is removed, otherwise false </dd></dl>

</div>
</div>
<a id="a4330bdd82d9261570e3f427a77bb367d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4330bdd82d9261570e3f427a77bb367d">&#9670;&nbsp;</a></span>isTargetMoving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IME::GridMover::isTargetMoving </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if target is moving or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if target is moving otherwise false</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will return false if the target is not moving or there is no target set. Therefore, the existence of the target should be checked first for accurate results</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_m_e_1_1_grid_mover.html#a7297d4a7e1f2ba86015f21b1e7999aa6" title="Get access to the controlled entity.">getTarget</a> </dd></dl>

</div>
</div>
<a id="a9a4ef7952bf3d8a5d2fcd69a020cf02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4ef7952bf3d8a5d2fcd69a020cf02c">&#9670;&nbsp;</a></span>onAdjacentTileReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onAdjacentTileReached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_graphics_1_1_tile.html">Graphics::Tile</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to an adjacent tile reached event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target reaches its target tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target moves from its current tile to any of its adjacent tiles.</p>
<dl class="section note"><dt>Note</dt><dd>When controlled by a grid mover, the target will always move one tile at a time, regardless of how fast the target is moving</dd></dl>
<p>The callback is passed the tile the target moved to </p>

</div>
</div>
<a id="a58fd836eaa9c7155fd201bc9d643b117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fd836eaa9c7155fd201bc9d643b117">&#9670;&nbsp;</a></span>onCollectableCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onCollectableCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a collectable collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with a collectable in the grid. The callback is passed the target as the first argument and the collectable it collided with as the second argument </p>

</div>
</div>
<a id="a2123d1fb1ec74b3d316af6f94e2e28c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2123d1fb1ec74b3d316af6f94e2e28c3">&#9670;&nbsp;</a></span>onEnemyCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onEnemyCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to an enemy collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with an enemy in the grid. The callback is passed the target as the first argument and the enemy it collided with as the second argument </p>

</div>
</div>
<a id="a72560ff0adf75480ee1b763d26abaa18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72560ff0adf75480ee1b763d26abaa18">&#9670;&nbsp;</a></span>onGridBorderCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onGridBorderCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt;&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a tilemap border collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target tries to go beyond the bounds of the grid. By default the event is handled internally before it's emitted to the outside. The internal handler prevents the target from leaving the grid. That is, the target will occupy the same tile it occupied before the collision. This behaviour is not removable, however, it may be overridden since the internal handler is called first before alerting external handlers </p>

</div>
</div>
<a id="a51ca1051448423e2ad9fc91279c56d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ca1051448423e2ad9fc91279c56d24">&#9670;&nbsp;</a></span>onInternalHandlerRemove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void IME::GridMover::onInternalHandlerRemove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a callback when an internal handler is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute</td></tr>
  </table>
  </dd>
</dl>
<p>This event is useful if derived classes rely on the internal collision handler behavior because they can adapt themselves when the handler is removed.</p>
<p>The callback is passed the name of the handler that got removed </p>

</div>
</div>
<a id="a1fd209b1bd94f6f62d75c62ef8dde9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd209b1bd94f6f62d75c62ef8dde9ff">&#9670;&nbsp;</a></span>onObstacleCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onObstacleCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to an obstacle collision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with an obstacle in the grid. By default the event is handled internally before its emitted to the outside. The internal handler prevents the target from occupying the same tile as the obstacle by moving it back to its previous tile after the collision. This behaviour may be removed if not desired by invoking </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_m_e_1_1_grid_mover.html#acae61f484b45612947b3ac0936a55c81" title="Remove the internal handler for a given collision event.">removeInternalCollisionHandlerFor()</a> with "obstacles" as the argument</dd></dl>
<p>The callback is passed the target as the first argument and the obstacle it collided with as the second argument </p>

</div>
</div>
<a id="a700278dce7fa07c91429de507aea9ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a700278dce7fa07c91429de507aea9ba2">&#9670;&nbsp;</a></span>onPlayerCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onPlayerCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>, <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a player collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with a player in the grid. The callback is passed the target as the first argument and the player it collided with as the second argument </p>

</div>
</div>
<a id="a6547008f49425fa4876c24cb53b249ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6547008f49425fa4876c24cb53b249ca">&#9670;&nbsp;</a></span>onSolidTileCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onSolidTileCollision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_graphics_1_1_tile.html">IME::Graphics::Tile</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a tile collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with a solid tile in the grid (Solid tiles are always collidable). By default, the event is handled internally before its emitted to the outside. The internal handler prevents the target from occupying the solid tile by moving it back to its previous tile after the collision. This behaviour may be removed if not desired by calling </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_m_e_1_1_grid_mover.html#acae61f484b45612947b3ac0936a55c81" title="Remove the internal handler for a given collision event.">removeInternalCollisionHandlerFor()</a> with "solidTiles" as the argument</dd></dl>
<p>The callback is passed the tile the target collided with </p>

</div>
</div>
<a id="a39df9a6e65753c590c1d8fff48d2eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39df9a6e65753c590c1d8fff48d2eb49">&#9670;&nbsp;</a></span>onTargetChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int IME::GridMover::onTargetChanged </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a76f0ed116a13d17e79db4af175d42344">Callback</a>&lt; <a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a target change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The callback will be passed the new target which may be a nullptr </dd></dl>

</div>
</div>
<a id="a186e70c1466d4f91619007d424705e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186e70c1466d4f91619007d424705e3e">&#9670;&nbsp;</a></span>removeCollisionHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IME::GridMover::removeCollisionHandler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handlerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an external collision handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlerId</td><td>Identification number of the handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the handler was removed or false if no such handler exits</dd></dl>
<p>The identification number is the number returned when a handler is added to a collision event </p>

</div>
</div>
<a id="acae61f484b45612947b3ac0936a55c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae61f484b45612947b3ac0936a55c81">&#9670;&nbsp;</a></span>removeInternalCollisionHandlerFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IME::GridMover::removeInternalCollisionHandlerFor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the internal handler for a given collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>Name of the handler to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the handler was removed or false if no such handler exists </dd></dl>

</div>
</div>
<a id="a7c0593390e3b9ff4c1dcfad0e6f67b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0593390e3b9ff4c1dcfad0e6f67b38">&#9670;&nbsp;</a></span>requestDirectionChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool IME::GridMover::requestDirectionChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_i_m_e.html#a049571570caab5e6dc75bf2075e5e89f">Direction</a>&#160;</td>
          <td class="paramname"><em>newDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the direction of the target entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDir</td><td>The new direction of the target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the direction was changed or false if the target is in motion or there is no target at all</dd></dl>
<p>The direction cannot be changed while the entity is moving to another tile. This function does not remember any direction change requests that were made while the target was moving. This function must be called even if the target is to be moved in its current direction as the target stops moving after reaching its destination</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_m_e_1_1_grid_mover.html#a89f3a2739ea58753defeab33b7e1c59a" title="Update entity movement in the grid.">update</a> </dd></dl>

</div>
</div>
<a id="a340c637dfdb14515499cbd4efe087b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340c637dfdb14515499cbd4efe087b54">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IME::GridMover::setTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_m_e_1_1_grid_mover.html#afce67fd4584edd1782b28d3158f51e89">EntityPtr</a>&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the controlled entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>New target</td></tr>
  </table>
  </dd>
</dl>
<p>Provide nullptr as argument to remove current target</p>
<dl class="section warning"><dt>Warning</dt><dd>if the target is not a nullptr, then it must exist in the grid prior to function call </dd></dl>

</div>
</div>
<a id="a0657c8c12c14a02025f3ab7fbbe62647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0657c8c12c14a02025f3ab7fbbe62647">&#9670;&nbsp;</a></span>teleportTargetToDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IME::GridMover::teleportTargetToDestination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the target to reach it's destination. </p>
<p>The destination in this context is always the adjacent tile the target is headed towards. This function has no effect if the target is not moving towards any tile </p>

</div>
</div>
<a id="a89f3a2739ea58753defeab33b7e1c59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f3a2739ea58753defeab33b7e1c59a">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void IME::GridMover::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>deltaTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update entity movement in the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deltaTime</td><td><a class="el" href="namespace_i_m_e_1_1_time.html" title="Container for all time related classes and functions.">Time</a> passed since movement was last updated</td></tr>
  </table>
  </dd>
</dl>
<p>The target can only move one tile at a time and cannot be instructed to move to another tile while it is currently moving to one of its adjacent tiles. After it reaching it's target tile it stops moving until instructed to move again. Therefore if the target is to be moved multiple tiles, the request to change direction must be made immediately after the target reaches its destination</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_i_m_e_1_1_grid_mover.html#a9a4ef7952bf3d8a5d2fcd69a020cf02c" title="Add an event listener to an adjacent tile reached event.">onAdjacentTileReached</a> and <a class="el" href="class_i_m_e_1_1_grid_mover.html#a7c0593390e3b9ff4c1dcfad0e6f67b38" title="Change the direction of the target entity.">requestDirectionChange</a></dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The target will never move if this function is never called </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_grid_mover_8h_source.html">GridMover.h</a></li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                IME is licensed under the terms and conditions of the <a href="https://github.com/KwenaMashamaite/IME/LICENSE">MIT license</a>.<br>
                Copyright &copy; Kwena Mashamaite
            </div>
        </div>
    </body>
</html>
