<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>IME - Infinite Motion Engine</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="ime">Documentation of IME 3.0.0</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.20 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceime.html">ime</a></li><li class="navelem"><a class="el" href="classime_1_1_grid_mover.html">GridMover</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classime_1_1_grid_mover-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ime::GridMover Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for performing grid based movement on an entity in a grid.  
 <a href="classime_1_1_grid_mover.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ime::GridMover:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classime_1_1_grid_mover.png" usemap="#ime::GridMover_map" alt=""/>
  <map id="ime::GridMover_map" name="ime::GridMover_map">
<area href="classime_1_1_object.html" title="An abstract top-level base class for IME objects." alt="ime::Object" shape="rect" coords="244,0,397,24"/>
<area href="classime_1_1_cyclic_grid_mover.html" title="Moves a game object in the grid along a cyclic path." alt="ime::CyclicGridMover" shape="rect" coords="0,112,153,136"/>
<area href="classime_1_1_keyboard_grid_mover.html" title="Moves a GridObject in the grid using the keyboard as a movement trigger." alt="ime::KeyboardGridMover" shape="rect" coords="163,112,316,136"/>
<area href="classime_1_1_random_grid_mover.html" title="Moves a GridObject randomly in a Grid2D." alt="ime::RandomGridMover" shape="rect" coords="326,112,479,136"/>
<area href="classime_1_1_target_grid_mover.html" title="Moves a GridObject to a specific position in the Grid2D." alt="ime::TargetGridMover" shape="rect" coords="489,112,642,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a07b612eb1a30ee0d7012a891a805e93a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a> { <br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aae1ba155a9f2e8c3be94020eef32a0301">Type::Manual</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aa64663f4646781c9c0110838b905daa23">Type::Random</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aac41a31890959544c6523af684561abe5">Type::Target</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aad71670d62b238eaf063979407361034e">Type::Cyclic</a>, 
<br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aaa55529813aef6ca28b9d22ee0442e02b">Type::KeyboardControlled</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aa90589c47f06eb971d548591f23c285af">Type::Custom</a>
<br />
 }</td></tr>
<tr class="memdesc:a07b612eb1a30ee0d7012a891a805e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of grid movers.  <a href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">More...</a><br /></td></tr>
<tr class="separator:a07b612eb1a30ee0d7012a891a805e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> { <br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca6adf97f83acf6453d4a6a4b1070f3754">MoveRestriction::None</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fcab1c94ca2fbc3e78fc30069c8d0f01680">MoveRestriction::All</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca06ce2a25e5d12c166a36f654dbea6012">MoveRestriction::Vertical</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fcac1b5fa03ecdb95d4a45dd1c40b02527f">MoveRestriction::Horizontal</a>, 
<br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca9ac677ee4eec25d9e59707a661d2c5e1">MoveRestriction::Diagonal</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca3e85a6323568ffe699745b4eef821495">MoveRestriction::NonDiagonal</a>
<br />
 }</td></tr>
<tr class="memdesc:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts the movement of the target along axes.  <a href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">More...</a><br /></td></tr>
<tr class="separator:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4db28c9ea63d1bd81a95823d020c178"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af4db28c9ea63d1bd81a95823d020c178">Ptr</a> = std::unique_ptr&lt; <a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &gt;</td></tr>
<tr class="memdesc:af4db28c9ea63d1bd81a95823d020c178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique grid mover pointer.  <a href="classime_1_1_grid_mover.html#af4db28c9ea63d1bd81a95823d020c178">More...</a><br /></td></tr>
<tr class="separator:af4db28c9ea63d1bd81a95823d020c178"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29dfdfadca133eff3a251dbdc27096dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a29dfdfadca133eff3a251dbdc27096dd">GridMover</a> (<a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;grid, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> *gameObject=nullptr)</td></tr>
<tr class="memdesc:a29dfdfadca133eff3a251dbdc27096dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a manually controlled grid mover.  <a href="classime_1_1_grid_mover.html#a29dfdfadca133eff3a251dbdc27096dd">More...</a><br /></td></tr>
<tr class="separator:a29dfdfadca133eff3a251dbdc27096dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c1d018077b6032d3473f5faab95549"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a81c1d018077b6032d3473f5faab95549">GridMover</a> (const <a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &amp;)=delete</td></tr>
<tr class="memdesc:a81c1d018077b6032d3473f5faab95549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classime_1_1_grid_mover.html#a81c1d018077b6032d3473f5faab95549">More...</a><br /></td></tr>
<tr class="separator:a81c1d018077b6032d3473f5faab95549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981cd5ffbdec5adb244730b0da55131d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a981cd5ffbdec5adb244730b0da55131d">operator=</a> (const <a class="el" href="classime_1_1_grid_mover.html">GridMover</a>)=delete</td></tr>
<tr class="memdesc:a981cd5ffbdec5adb244730b0da55131d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classime_1_1_grid_mover.html#a981cd5ffbdec5adb244730b0da55131d">More...</a><br /></td></tr>
<tr class="separator:a981cd5ffbdec5adb244730b0da55131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a8e3a0ca52ae74832ef1525671ba1b49c">getClassType</a> () const override</td></tr>
<tr class="memdesc:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this class.  <a href="classime_1_1_grid_mover.html#a8e3a0ca52ae74832ef1525671ba1b49c">More...</a><br /></td></tr>
<tr class="separator:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1482324fd09f1d7b544372e6ef108d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a3b1482324fd09f1d7b544372e6ef108d">getClassName</a> () const override</td></tr>
<tr class="memdesc:a3b1482324fd09f1d7b544372e6ef108d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this class.  <a href="classime_1_1_grid_mover.html#a3b1482324fd09f1d7b544372e6ef108d">More...</a><br /></td></tr>
<tr class="separator:a3b1482324fd09f1d7b544372e6ef108d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0627539f4f7e59a9905c4d9d37396089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a0627539f4f7e59a9905c4d9d37396089">syncWith</a> (const <a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &amp;other)</td></tr>
<tr class="memdesc:a0627539f4f7e59a9905c4d9d37396089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sync this grid mover with another grid mover.  <a href="classime_1_1_grid_mover.html#a0627539f4f7e59a9905c4d9d37396089">More...</a><br /></td></tr>
<tr class="separator:a0627539f4f7e59a9905c4d9d37396089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5a2809795725446f88f0ed90f4c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a82d5a2809795725446f88f0ed90f4c71">requestMove</a> (const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;dir)</td></tr>
<tr class="memdesc:a82d5a2809795725446f88f0ed90f4c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a move in a given direction.  <a href="classime_1_1_grid_mover.html#a82d5a2809795725446f88f0ed90f4c71">More...</a><br /></td></tr>
<tr class="separator:a82d5a2809795725446f88f0ed90f4c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266600fc2eef282439b2d507b358c427"><td class="memItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a266600fc2eef282439b2d507b358c427">isBlockedInDirection</a> (const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;direction) const</td></tr>
<tr class="memdesc:a266600fc2eef282439b2d507b358c427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the target is blocked from moving in a direction.  <a href="classime_1_1_grid_mover.html#a266600fc2eef282439b2d507b358c427">More...</a><br /></td></tr>
<tr class="separator:a266600fc2eef282439b2d507b358c427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ab796c7ce3807533afd9d64bce8425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a39ab796c7ce3807533afd9d64bce8425">getDirection</a> () const</td></tr>
<tr class="memdesc:a39ab796c7ce3807533afd9d64bce8425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current direction of the game object.  <a href="classime_1_1_grid_mover.html#a39ab796c7ce3807533afd9d64bce8425">More...</a><br /></td></tr>
<tr class="separator:a39ab796c7ce3807533afd9d64bce8425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986f4a16ef608e0873ee2c8a1455c65f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a986f4a16ef608e0873ee2c8a1455c65f">getPrevDirection</a> () const</td></tr>
<tr class="memdesc:a986f4a16ef608e0873ee2c8a1455c65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous direction of the target.  <a href="classime_1_1_grid_mover.html#a986f4a16ef608e0873ee2c8a1455c65f">More...</a><br /></td></tr>
<tr class="separator:a986f4a16ef608e0873ee2c8a1455c65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8a2eb07cdf61592f63a32e8e88436f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f">setTarget</a> (<a class="el" href="classime_1_1_grid_object.html">GridObject</a> *target)</td></tr>
<tr class="memdesc:a2b8a2eb07cdf61592f63a32e8e88436f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the controlled entity.  <a href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f">More...</a><br /></td></tr>
<tr class="separator:a2b8a2eb07cdf61592f63a32e8e88436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519ad160ab2062363eb65a596f61d4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_object.html">GridObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#aa519ad160ab2062363eb65a596f61d4a">getTarget</a> () const</td></tr>
<tr class="memdesc:aa519ad160ab2062363eb65a596f61d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the controlled entity.  <a href="classime_1_1_grid_mover.html#aa519ad160ab2062363eb65a596f61d4a">More...</a><br /></td></tr>
<tr class="separator:aa519ad160ab2062363eb65a596f61d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3898f9de6562ae8ff0ab9a6b7c813f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ada3898f9de6562ae8ff0ab9a6b7c813f">setSpeed</a> (const <a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> &amp;speed)</td></tr>
<tr class="memdesc:ada3898f9de6562ae8ff0ab9a6b7c813f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the speed of the game object.  <a href="classime_1_1_grid_mover.html#ada3898f9de6562ae8ff0ab9a6b7c813f">More...</a><br /></td></tr>
<tr class="separator:ada3898f9de6562ae8ff0ab9a6b7c813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d91709a02eb517e68edb798949bd91d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a6d91709a02eb517e68edb798949bd91d">getSpeed</a> () const</td></tr>
<tr class="memdesc:a6d91709a02eb517e68edb798949bd91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the speed of the target.  <a href="classime_1_1_grid_mover.html#a6d91709a02eb517e68edb798949bd91d">More...</a><br /></td></tr>
<tr class="separator:a6d91709a02eb517e68edb798949bd91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9c1ee303df652a29e07ac33ecb00b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a3a9c1ee303df652a29e07ac33ecb00b7">setSpeedMultiplier</a> (float multiplier)</td></tr>
<tr class="memdesc:a3a9c1ee303df652a29e07ac33ecb00b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a speed multiplier.  <a href="classime_1_1_grid_mover.html#a3a9c1ee303df652a29e07ac33ecb00b7">More...</a><br /></td></tr>
<tr class="separator:a3a9c1ee303df652a29e07ac33ecb00b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf2934181430189656188257bd77ed5b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#acf2934181430189656188257bd77ed5b">getSpeedMultiplier</a> () const</td></tr>
<tr class="memdesc:acf2934181430189656188257bd77ed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the speed multiplier.  <a href="classime_1_1_grid_mover.html#acf2934181430189656188257bd77ed5b">More...</a><br /></td></tr>
<tr class="separator:acf2934181430189656188257bd77ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121bf39232196e459b0c0b619e963c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b">setMovementRestriction</a> (<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> moveRestriction)</td></tr>
<tr class="memdesc:a121bf39232196e459b0c0b619e963c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the movement of the game object to certain directions.  <a href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b">More...</a><br /></td></tr>
<tr class="separator:a121bf39232196e459b0c0b619e963c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a04e9f2ca7f76fd6c6278797ab46e6a65">getMovementRestriction</a> () const</td></tr>
<tr class="memdesc:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current movement restriction of the game object.  <a href="classime_1_1_grid_mover.html#a04e9f2ca7f76fd6c6278797ab46e6a65">More...</a><br /></td></tr>
<tr class="separator:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a264750eeefd2cacf760ad9d785d3a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7">setMovementFreeze</a> (bool freeze)</td></tr>
<tr class="memdesc:a2a264750eeefd2cacf760ad9d785d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freeze or unfreeze the targets movement.  <a href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7">More...</a><br /></td></tr>
<tr class="separator:a2a264750eeefd2cacf760ad9d785d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c162f7555b076e7a490baca60edcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a7f7c162f7555b076e7a490baca60edcd">isMovementFrozen</a> () const</td></tr>
<tr class="memdesc:a7f7c162f7555b076e7a490baca60edcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the targets movement is frozen or not.  <a href="classime_1_1_grid_mover.html#a7f7c162f7555b076e7a490baca60edcd">More...</a><br /></td></tr>
<tr class="separator:a7f7c162f7555b076e7a490baca60edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9fa52e0e29d28c988b1d645e1e29ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structime_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#aaf9fa52e0e29d28c988b1d645e1e29ce">getCurrentTileIndex</a> () const</td></tr>
<tr class="memdesc:aaf9fa52e0e29d28c988b1d645e1e29ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the tile currently occupied by the target.  <a href="classime_1_1_grid_mover.html#aaf9fa52e0e29d28c988b1d645e1e29ce">More...</a><br /></td></tr>
<tr class="separator:aaf9fa52e0e29d28c988b1d645e1e29ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75dd6cd8343b1741e88ff8de80c5830f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structime_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a75dd6cd8343b1741e88ff8de80c5830f">getPrevTileIndex</a> () const</td></tr>
<tr class="memdesc:a75dd6cd8343b1741e88ff8de80c5830f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the tile previously occupied by the target.  <a href="classime_1_1_grid_mover.html#a75dd6cd8343b1741e88ff8de80c5830f">More...</a><br /></td></tr>
<tr class="separator:a75dd6cd8343b1741e88ff8de80c5830f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af8722af658036b2f6b7b40fe5bdbf1e4">getType</a> () const</td></tr>
<tr class="memdesc:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the grid mover.  <a href="classime_1_1_grid_mover.html#af8722af658036b2f6b7b40fe5bdbf1e4">More...</a><br /></td></tr>
<tr class="separator:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7872637d83ac8efddac5a4bf956469f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a7872637d83ac8efddac5a4bf956469f6">getGrid</a> ()</td></tr>
<tr class="memdesc:a7872637d83ac8efddac5a4bf956469f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the grid in which the target is moved in.  <a href="classime_1_1_grid_mover.html#a7872637d83ac8efddac5a4bf956469f6">More...</a><br /></td></tr>
<tr class="separator:a7872637d83ac8efddac5a4bf956469f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9931ef1befa0706199222f851fb9f1b7"><td class="memItemLeft" align="right" valign="top"><a id="a9931ef1befa0706199222f851fb9f1b7"></a>
const <a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getGrid</b> () const</td></tr>
<tr class="separator:a9931ef1befa0706199222f851fb9f1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f703bf9dfc0c91c76716dac3ded84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af2f703bf9dfc0c91c76716dac3ded84a">isTargetMoving</a> () const</td></tr>
<tr class="memdesc:af2f703bf9dfc0c91c76716dac3ded84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if target is moving or not.  <a href="classime_1_1_grid_mover.html#af2f703bf9dfc0c91c76716dac3ded84a">More...</a><br /></td></tr>
<tr class="separator:af2f703bf9dfc0c91c76716dac3ded84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1861b96d89d9bc4539eda2cdacd356b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a1861b96d89d9bc4539eda2cdacd356b8">teleportTargetToDestination</a> ()</td></tr>
<tr class="memdesc:a1861b96d89d9bc4539eda2cdacd356b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the target to reach it's destination.  <a href="classime_1_1_grid_mover.html#a1861b96d89d9bc4539eda2cdacd356b8">More...</a><br /></td></tr>
<tr class="separator:a1861b96d89d9bc4539eda2cdacd356b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54c01c573b9b968117a0b5ef0fd8618"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#aa54c01c573b9b968117a0b5ef0fd8618">onDirectionChange</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:aa54c01c573b9b968117a0b5ef0fd8618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a target direction change.  <a href="classime_1_1_grid_mover.html#aa54c01c573b9b968117a0b5ef0fd8618">More...</a><br /></td></tr>
<tr class="separator:aa54c01c573b9b968117a0b5ef0fd8618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade350b65cfb3791254d942550882b895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ade350b65cfb3791254d942550882b895">resetTargetTile</a> ()</td></tr>
<tr class="memdesc:ade350b65cfb3791254d942550882b895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the target tile to be the same as the entity tile.  <a href="classime_1_1_grid_mover.html#ade350b65cfb3791254d942550882b895">More...</a><br /></td></tr>
<tr class="separator:ade350b65cfb3791254d942550882b895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f61b75e33ec1e8ef9a3da3076938d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a77f61b75e33ec1e8ef9a3da3076938d0">onTargetTileReset</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a77f61b75e33ec1e8ef9a3da3076938d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to target tile reset event.  <a href="classime_1_1_grid_mover.html#a77f61b75e33ec1e8ef9a3da3076938d0">More...</a><br /></td></tr>
<tr class="separator:a77f61b75e33ec1e8ef9a3da3076938d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a044636465db4810ae547e248049bc"><td class="memItemLeft" align="right" valign="top"><a id="a79a044636465db4810ae547e248049bc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> (<a class="el" href="classime_1_1_time.html">Time</a> deltaTime)</td></tr>
<tr class="separator:a79a044636465db4810ae547e248049bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8181e77c50a31a9200e7f64120144ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#aa8181e77c50a31a9200e7f64120144ec">onMoveBegin</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:aa8181e77c50a31a9200e7f64120144ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a move begin event.  <a href="classime_1_1_grid_mover.html#aa8181e77c50a31a9200e7f64120144ec">More...</a><br /></td></tr>
<tr class="separator:aa8181e77c50a31a9200e7f64120144ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f1bbb0367901e3f8b79dfb4d764e8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a37f1bbb0367901e3f8b79dfb4d764e8e">onMoveEnd</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a37f1bbb0367901e3f8b79dfb4d764e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an adjacent tile reached event.  <a href="classime_1_1_grid_mover.html#a37f1bbb0367901e3f8b79dfb4d764e8e">More...</a><br /></td></tr>
<tr class="separator:a37f1bbb0367901e3f8b79dfb4d764e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a395c13ead1ca472909d9d1f77993"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ae56a395c13ead1ca472909d9d1f77993">onObjectCollision</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_grid_object.html">GridObject</a> *, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> * &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:ae56a395c13ead1ca472909d9d1f77993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a grid collision event event.  <a href="classime_1_1_grid_mover.html#ae56a395c13ead1ca472909d9d1f77993">More...</a><br /></td></tr>
<tr class="separator:ae56a395c13ead1ca472909d9d1f77993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a29c1e5ea9348913794d21428197b13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a8a29c1e5ea9348913794d21428197b13">onBorderCollision</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a8a29c1e5ea9348913794d21428197b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a grid border collision event.  <a href="classime_1_1_grid_mover.html#a8a29c1e5ea9348913794d21428197b13">More...</a><br /></td></tr>
<tr class="separator:a8a29c1e5ea9348913794d21428197b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0ec54bb9214803536761cc7cd9a18a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a6a0ec54bb9214803536761cc7cd9a18a">onTileCollision</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a6a0ec54bb9214803536761cc7cd9a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a tile collision event.  <a href="classime_1_1_grid_mover.html#a6a0ec54bb9214803536761cc7cd9a18a">More...</a><br /></td></tr>
<tr class="separator:a6a0ec54bb9214803536761cc7cd9a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc3597be8e28cba4d51a642b5ac493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a2fc3597be8e28cba4d51a642b5ac493c">~GridMover</a> () override</td></tr>
<tr class="memdesc:a2fc3597be8e28cba4d51a642b5ac493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classime_1_1_grid_mover.html#a2fc3597be8e28cba4d51a642b5ac493c">More...</a><br /></td></tr>
<tr class="separator:a2fc3597be8e28cba4d51a642b5ac493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">setTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the object an alias.  <a href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">More...</a><br /></td></tr>
<tr class="separator:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ab83221ea2cf2002ee4657cc8b3d39c87">getTag</a> () const</td></tr>
<tr class="memdesc:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tag assigned to the object.  <a href="classime_1_1_object.html#ab83221ea2cf2002ee4657cc8b3d39c87">More...</a><br /></td></tr>
<tr class="separator:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9c8f45f13c68e129775bc058231af"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af">getObjectId</a> () const</td></tr>
<tr class="memdesc:ac2e9c8f45f13c68e129775bc058231af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of the object.  <a href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af">More...</a><br /></td></tr>
<tr class="separator:ac2e9c8f45f13c68e129775bc058231af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5d4f512ca54743a3d5ab21c2022050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a0a5d4f512ca54743a3d5ab21c2022050">onPropertyChange</a> (const std::string &amp;property, const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a0a5d4f512ca54743a3d5ab21c2022050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a specific property change event.  <a href="classime_1_1_object.html#a0a5d4f512ca54743a3d5ab21c2022050">More...</a><br /></td></tr>
<tr class="separator:a0a5d4f512ca54743a3d5ab21c2022050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e4e9783f6eb2de80ae33435381f453"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a50e4e9783f6eb2de80ae33435381f453">onPropertyChange</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;callback, bool oneTime=false)</td></tr>
<tr class="memdesc:a50e4e9783f6eb2de80ae33435381f453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to any property change event.  <a href="classime_1_1_object.html#a50e4e9783f6eb2de80ae33435381f453">More...</a><br /></td></tr>
<tr class="separator:a50e4e9783f6eb2de80ae33435381f453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad38f902db7325b4898fdbe2830ef898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#aad38f902db7325b4898fdbe2830ef898">suspendedEventListener</a> (int id, bool suspend)</td></tr>
<tr class="memdesc:aad38f902db7325b4898fdbe2830ef898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause or resume execution of an event listener.  <a href="classime_1_1_object.html#aad38f902db7325b4898fdbe2830ef898">More...</a><br /></td></tr>
<tr class="separator:aad38f902db7325b4898fdbe2830ef898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedadb2161e63cb84f2964e3e4b03b4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#acedadb2161e63cb84f2964e3e4b03b4f">isEventListenerSuspended</a> (int id) const</td></tr>
<tr class="memdesc:acedadb2161e63cb84f2964e3e4b03b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if an event listener is suspended or not.  <a href="classime_1_1_object.html#acedadb2161e63cb84f2964e3e4b03b4f">More...</a><br /></td></tr>
<tr class="separator:acedadb2161e63cb84f2964e3e4b03b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62658e4b24f61452ae7308f8bdf23994"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a62658e4b24f61452ae7308f8bdf23994">removeEventListener</a> (const std::string &amp;event, int id)</td></tr>
<tr class="memdesc:a62658e4b24f61452ae7308f8bdf23994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an event listener from an event.  <a href="classime_1_1_object.html#a62658e4b24f61452ae7308f8bdf23994">More...</a><br /></td></tr>
<tr class="separator:a62658e4b24f61452ae7308f8bdf23994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f5fcb279d0bd9f58faffe663d19554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a33f5fcb279d0bd9f58faffe663d19554">removeEventListener</a> (int id)</td></tr>
<tr class="memdesc:a33f5fcb279d0bd9f58faffe663d19554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an event listener.  <a href="classime_1_1_object.html#a33f5fcb279d0bd9f58faffe663d19554">More...</a><br /></td></tr>
<tr class="separator:a33f5fcb279d0bd9f58faffe663d19554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cca84e762939e48b6949d0aa87e571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a13cca84e762939e48b6949d0aa87e571">onDestruction</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback)</td></tr>
<tr class="memdesc:a13cca84e762939e48b6949d0aa87e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a destruction listener.  <a href="classime_1_1_object.html#a13cca84e762939e48b6949d0aa87e571">More...</a><br /></td></tr>
<tr class="separator:a13cca84e762939e48b6949d0aa87e571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c92fb0cf8a7b25988b91c01ccb3320c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a3c92fb0cf8a7b25988b91c01ccb3320c">isSameObjectAs</a> (const <a class="el" href="classime_1_1_object.html">Object</a> &amp;other) const</td></tr>
<tr class="memdesc:a3c92fb0cf8a7b25988b91c01ccb3320c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if another object is the same instance as this object.  <a href="classime_1_1_object.html#a3c92fb0cf8a7b25988b91c01ccb3320c">More...</a><br /></td></tr>
<tr class="separator:a3c92fb0cf8a7b25988b91c01ccb3320c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a6aca9e507bd0022498f3faa7d4d72dbb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classime_1_1_grid_mover.html#af4db28c9ea63d1bd81a95823d020c178">GridMover::Ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a6aca9e507bd0022498f3faa7d4d72dbb">create</a> (<a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;grid, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> *gameObject=nullptr)</td></tr>
<tr class="memdesc:a6aca9e507bd0022498f3faa7d4d72dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the grid mover.  <a href="classime_1_1_grid_mover.html#a6aca9e507bd0022498f3faa7d4d72dbb">More...</a><br /></td></tr>
<tr class="separator:a6aca9e507bd0022498f3faa7d4d72dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a785b3ecd5965e09ce976a126514b8e6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a785b3ecd5965e09ce976a126514b8e6c">GridMover</a> (<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a> type, <a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;grid, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> *target)</td></tr>
<tr class="memdesc:a785b3ecd5965e09ce976a126514b8e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a grid mover.  <a href="classime_1_1_grid_mover.html#a785b3ecd5965e09ce976a126514b8e6c">More...</a><br /></td></tr>
<tr class="separator:a785b3ecd5965e09ce976a126514b8e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f">emitChange</a> (const <a class="el" href="classime_1_1_property.html">Property</a> &amp;property)</td></tr>
<tr class="memdesc:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a property change event.  <a href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f">More...</a><br /></td></tr>
<tr class="separator:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a805a30e8835e41133a4bdbfbed2e1b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_event_emitter.html">EventEmitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a805a30e8835e41133a4bdbfbed2e1b52">eventEmitter_</a></td></tr>
<tr class="memdesc:a805a30e8835e41133a4bdbfbed2e1b52"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classime_1_1_event.html" title="Defines a system event and its parameters.">Event</a> dispatcher.  <a href="classime_1_1_object.html#a805a30e8835e41133a4bdbfbed2e1b52">More...</a><br /></td></tr>
<tr class="separator:a805a30e8835e41133a4bdbfbed2e1b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for performing grid based movement on an entity in a grid. </p>
<p>This class monitors the movement of an entity in a grid and ensures that it always moves from one cell to the next and never between grid cells. The entities direction cannot be changed until it has completed it's current movement. </p>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00056">56</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af4db28c9ea63d1bd81a95823d020c178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4db28c9ea63d1bd81a95823d020c178">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_grid_mover.html#af4db28c9ea63d1bd81a95823d020c178">ime::GridMover::Ptr</a> =  std::unique_ptr&lt;<a class="el" href="classime_1_1_grid_mover.html">GridMover</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique grid mover pointer. </p>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00058">58</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a62c372e0dbb8e5a0be9b8fa5fd9724fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c372e0dbb8e5a0be9b8fa5fd9724fc">&#9670;&nbsp;</a></span>MoveRestriction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">ime::GridMover::MoveRestriction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts the movement of the target along axes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Target can move in all in all 8 directions (W, NW, N, NE, E, SE, S, SW) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fcab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Target cannot move in any direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca06ce2a25e5d12c166a36f654dbea6012"></a>Vertical&#160;</td><td class="fielddoc"><p>Target can only move vertically (N or S) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fcac1b5fa03ecdb95d4a45dd1c40b02527f"></a>Horizontal&#160;</td><td class="fielddoc"><p>Target can only move horizontally (W or E) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca9ac677ee4eec25d9e59707a661d2c5e1"></a>Diagonal&#160;</td><td class="fielddoc"><p>Target can only move diagonally (NW, NE, SE, SW) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca3e85a6323568ffe699745b4eef821495"></a>NonDiagonal&#160;</td><td class="fielddoc"><p>Target can only move non-diagonally (W, N, E, S) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00075">75</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<a id="a07b612eb1a30ee0d7012a891a805e93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b612eb1a30ee0d7012a891a805e93a">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">ime::GridMover::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of grid movers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aae1ba155a9f2e8c3be94020eef32a0301"></a>Manual&#160;</td><td class="fielddoc"><p>Manually triggered grid mover. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aa64663f4646781c9c0110838b905daa23"></a>Random&#160;</td><td class="fielddoc"><p>Moves a game object randomly in the grid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aac41a31890959544c6523af684561abe5"></a>Target&#160;</td><td class="fielddoc"><p>Moves a game object to a specific tile within the grid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aad71670d62b238eaf063979407361034e"></a>Cyclic&#160;</td><td class="fielddoc"><p>Moves a game object by following a closed path. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aaa55529813aef6ca28b9d22ee0442e02b"></a>KeyboardControlled&#160;</td><td class="fielddoc"><p>Moves a game object within the grid using the keyboard as a trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aa90589c47f06eb971d548591f23c285af"></a>Custom&#160;</td><td class="fielddoc"><p>For classes that extend the grid mover outside of IME. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00063">63</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a29dfdfadca133eff3a251dbdc27096dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dfdfadca133eff3a251dbdc27096dd">&#9670;&nbsp;</a></span>GridMover() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::GridMover::GridMover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>gameObject</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a manually controlled grid mover. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid the game object is in </td></tr>
    <tr><td class="paramname">gameObject</td><td>The game object to be controlled by the grid mover</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>If <em>gameObject</em> is left as <em>nullptr</em>, then <a class="el" href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f" title="Change the controlled entity.">setTarget()</a> must be called before the grid mover is used. If the <em>gameObject</em> is given, it must be in the grid prior to constructor call and it must not have a <a class="el" href="classime_1_1_rigid_body.html" title="A rigid body.">RigidBody</a> attached to it, otherwise undefined behavior</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f" title="Change the controlled entity.">setTarget</a> </dd></dl>

</div>
</div>
<a id="a81c1d018077b6032d3473f5faab95549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c1d018077b6032d3473f5faab95549">&#9670;&nbsp;</a></span>GridMover() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::GridMover::GridMover </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a2fc3597be8e28cba4d51a642b5ac493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fc3597be8e28cba4d51a642b5ac493c">&#9670;&nbsp;</a></span>~GridMover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::GridMover::~GridMover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a785b3ecd5965e09ce976a126514b8e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785b3ecd5965e09ce976a126514b8e6c">&#9670;&nbsp;</a></span>GridMover() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::GridMover::GridMover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a grid mover. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the grid mover </td></tr>
    <tr><td class="paramname">grid</td><td>Grid to move a target entity in </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classime_1_1_grid_object.html" title="An object that can be placed in a Grid2D.">GridObject</a> to be moved in the grid</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this constructor is intended to be used by derived classes such that the user cannot change the type of the grid mover during instantiation. The public constructor sets the type to <a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aae1ba155a9f2e8c3be94020eef32a0301" title="Manually triggered grid mover.">Type::Manual</a> and it cannot be changed once set. Since derived classes must set their own type, they use this constructor to initialize the base class</p>
<dl class="section warning"><dt>Warning</dt><dd>if the target is not a nullptr, then it must be placed in the grid prior to instantiation of this class </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6aca9e507bd0022498f3faa7d4d72dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aca9e507bd0022498f3faa7d4d72dbb">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classime_1_1_grid_mover.html#af4db28c9ea63d1bd81a95823d020c178">GridMover::Ptr</a> ime::GridMover::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid2_d.html">Grid2D</a> &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>gameObject</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the grid mover. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>The grid the game object is in </td></tr>
    <tr><td class="paramname">gameObject</td><td>The game object to be controlled by the grid mover </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created grid mover</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If <em>gameObject</em> is left as <em>nullptr</em>, then <a class="el" href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f" title="Change the controlled entity.">setTarget()</a> must be called before the grid mover is used. If the <em>gameObject</em> is given, it must be in the grid prior to constructor call and it must not have a <a class="el" href="classime_1_1_rigid_body.html" title="A rigid body.">RigidBody</a> attached to it, otherwise undefined behavior</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2b8a2eb07cdf61592f63a32e8e88436f" title="Change the controlled entity.">setTarget</a> </dd></dl>

</div>
</div>
<a id="a18e26cf15b23c3f2a349ace7ec17cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e26cf15b23c3f2a349ace7ec17cb2f">&#9670;&nbsp;</a></span>emitChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::emitChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_property.html">Property</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch a property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The property that changed</td></tr>
  </table>
  </dd>
</dl>
<p>This function will invoke all the event listeners of the specified property</p>
<dl class="section see"><dt>See also</dt><dd>emit </dd></dl>

</div>
</div>
<a id="a3b1482324fd09f1d7b544372e6ef108d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1482324fd09f1d7b544372e6ef108d">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ime::GridMover::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class </dd></dl>

<p>Implements <a class="el" href="classime_1_1_object.html#a893e90e8498458bd9d43fe9041a22f02">ime::Object</a>.</p>

<p>Reimplemented in <a class="el" href="classime_1_1_target_grid_mover.html#ad52bbb5eb1a4052656dda478b89e4c6e">ime::TargetGridMover</a>, <a class="el" href="classime_1_1_random_grid_mover.html#a41ba8d414a8f63dbbe11220df1e6e4a5">ime::RandomGridMover</a>, and <a class="el" href="classime_1_1_keyboard_grid_mover.html#a49b5520a01fcb72e1c1f63525121b488">ime::KeyboardGridMover</a>.</p>

</div>
</div>
<a id="a8e3a0ca52ae74832ef1525671ba1b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3a0ca52ae74832ef1525671ba1b49c">&#9670;&nbsp;</a></span>getClassType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ime::GridMover::getClassType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class</dd></dl>
<p>Note that this function is only implemented by child classes of <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> which also serve as a base class for other classes</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#a8c3d545176c422a07532de6e2eb35f84" title="Get the name of the direct parent of an object instance.">Object::getClassType</a> and <a class="el" href="classime_1_1_object.html#a893e90e8498458bd9d43fe9041a22f02" title="Get the name of the objects concrete class.">Object::getClassName</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classime_1_1_object.html#a8c3d545176c422a07532de6e2eb35f84">ime::Object</a>.</p>

</div>
</div>
<a id="aaf9fa52e0e29d28c988b1d645e1e29ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9fa52e0e29d28c988b1d645e1e29ce">&#9670;&nbsp;</a></span>getCurrentTileIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structime_1_1_index.html">Index</a> ime::GridMover::getCurrentTileIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the tile currently occupied by the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the tile currently occupied by the target in tiles</dd></dl>
<p>Recall that when moved, the target occupies a tile ahead of time (see <a class="el" href="classime_1_1_grid_mover.html#a82d5a2809795725446f88f0ed90f4c71" title="Request a move in a given direction.">requestMove()</a>)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a75dd6cd8343b1741e88ff8de80c5830f" title="Get the index of the tile previously occupied by the target.">getPrevTileIndex</a> </dd></dl>

</div>
</div>
<a id="a39ab796c7ce3807533afd9d64bce8425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ab796c7ce3807533afd9d64bce8425">&#9670;&nbsp;</a></span>getDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> ime::GridMover::getDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current direction of the game object. </p>
<dl class="section return"><dt>Returns</dt><dd>The current direction of the game object </dd></dl>

</div>
</div>
<a id="a7872637d83ac8efddac5a4bf956469f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7872637d83ac8efddac5a4bf956469f6">&#9670;&nbsp;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid2_d.html">Grid2D</a>&amp; ime::GridMover::getGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the grid in which the target is moved in. </p>
<dl class="section return"><dt>Returns</dt><dd>The grid in which the target is being moved in </dd></dl>

</div>
</div>
<a id="a04e9f2ca7f76fd6c6278797ab46e6a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e9f2ca7f76fd6c6278797ab46e6a65">&#9670;&nbsp;</a></span>getMovementRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> ime::GridMover::getMovementRestriction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current movement restriction of the game object. </p>
<dl class="section return"><dt>Returns</dt><dd>The current movement restriction </dd></dl>

</div>
</div>
<a id="ac2e9c8f45f13c68e129775bc058231af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9c8f45f13c68e129775bc058231af">&#9670;&nbsp;</a></span>getObjectId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ime::Object::getObjectId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique id of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the object</dd></dl>
<p>Note that each instance of <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">ime::Object</a> has a unique id</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag</a> </dd></dl>

</div>
</div>
<a id="a986f4a16ef608e0873ee2c8a1455c65f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986f4a16ef608e0873ee2c8a1455c65f">&#9670;&nbsp;</a></span>getPrevDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> ime::GridMover::getPrevDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the previous direction of the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The previous direction of the target </dd></dl>

</div>
</div>
<a id="a75dd6cd8343b1741e88ff8de80c5830f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75dd6cd8343b1741e88ff8de80c5830f">&#9670;&nbsp;</a></span>getPrevTileIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structime_1_1_index.html">Index</a> ime::GridMover::getPrevTileIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the tile previously occupied by the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The tile the target was on before moving to another tile</dd></dl>
<p>If the target never moved, then this function will return the tile currently occupied by the target</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#aaf9fa52e0e29d28c988b1d645e1e29ce" title="Get the index of the tile currently occupied by the target.">getCurrentTileIndex</a> </dd></dl>

</div>
</div>
<a id="a6d91709a02eb517e68edb798949bd91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d91709a02eb517e68edb798949bd91d">&#9670;&nbsp;</a></span>getSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a>&amp; ime::GridMover::getSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the speed of the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The speed of the target</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ada3898f9de6562ae8ff0ab9a6b7c813f" title="Set the speed of the game object.">setSpeed</a> </dd></dl>

</div>
</div>
<a id="acf2934181430189656188257bd77ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf2934181430189656188257bd77ed5b">&#9670;&nbsp;</a></span>getSpeedMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ime::GridMover::getSpeedMultiplier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the speed multiplier. </p>
<dl class="section return"><dt>Returns</dt><dd>The speed multiplier</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a3a9c1ee303df652a29e07ac33ecb00b7" title="Set a speed multiplier.">setSpeedMultiplier</a> </dd></dl>

</div>
</div>
<a id="ab83221ea2cf2002ee4657cc8b3d39c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83221ea2cf2002ee4657cc8b3d39c87">&#9670;&nbsp;</a></span>getTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ime::Object::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tag assigned to the object. </p>
<dl class="section return"><dt>Returns</dt><dd>The tag of the object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag</a> </dd></dl>

</div>
</div>
<a id="aa519ad160ab2062363eb65a596f61d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa519ad160ab2062363eb65a596f61d4a">&#9670;&nbsp;</a></span>getTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_object.html">GridObject</a>* ime::GridMover::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the controlled entity. </p>
<dl class="section return"><dt>Returns</dt><dd>The controlled entity, or a nullptr if there is no entity to control </dd></dl>

</div>
</div>
<a id="af8722af658036b2f6b7b40fe5bdbf1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8722af658036b2f6b7b40fe5bdbf1e4">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a> ime::GridMover::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the type of the grid mover. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the grid mover </dd></dl>

</div>
</div>
<a id="a266600fc2eef282439b2d507b358c427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266600fc2eef282439b2d507b358c427">&#9670;&nbsp;</a></span>isBlockedInDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;bool, <a class="el" href="classime_1_1_grid_object.html">GridObject</a>*&gt; ime::GridMover::isBlockedInDirection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the target is blocked from moving in a direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>The direction to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair, of which the first element is a bool that is <em>true</em> if the target is blocked or <em>false</em> if the target is not blocked and the second element is a pointer to an obstacle game object that is a <em>nullptr</em> when the first element is <em>false</em> or when the first element is <em>true</em> but the target is not blocked by a game object</dd></dl>
<p>This function will return true if the target is blocked by a collidable tile or an obstacle (see <a class="el" href="classime_1_1_grid_object.html#aca9560d767b3ecbd1c46667886bd8c1b" title="Set whether or not the game object is an obstacle.">ime::GridObject::setObstacle</a>), or if a move in the given direction will place it outside the bounds of the grid </p>

</div>
</div>
<a id="acedadb2161e63cb84f2964e3e4b03b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedadb2161e63cb84f2964e3e4b03b4f">&#9670;&nbsp;</a></span>isEventListenerSuspended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::isEventListenerSuspended </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if an event listener is suspended or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The identification number of the listener to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if suspended, otherwise false</dd></dl>
<p>This function also returns false if the specified event listener does not exist</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#aad38f902db7325b4898fdbe2830ef898" title="Pause or resume execution of an event listener.">suspendedEventListener</a> </dd></dl>

</div>
</div>
<a id="a7f7c162f7555b076e7a490baca60edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7c162f7555b076e7a490baca60edcd">&#9670;&nbsp;</a></span>isMovementFrozen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::isMovementFrozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the targets movement is frozen or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if movement is frozen otherwise false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7" title="Freeze or unfreeze the targets movement.">setMovementFreeze</a> </dd></dl>

</div>
</div>
<a id="a3c92fb0cf8a7b25988b91c01ccb3320c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c92fb0cf8a7b25988b91c01ccb3320c">&#9670;&nbsp;</a></span>isSameObjectAs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::isSameObjectAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if another object is the same instance as this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object to compare against this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>other</em> is the same instance as this object, otherwise false </dd></dl>

</div>
</div>
<a id="af2f703bf9dfc0c91c76716dac3ded84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f703bf9dfc0c91c76716dac3ded84a">&#9670;&nbsp;</a></span>isTargetMoving()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::isTargetMoving </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if target is moving or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if target is moving otherwise false</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will return false if the target is not moving or there is no target set. Therefore, the existence of the target should be checked first for accurate results</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#aa519ad160ab2062363eb65a596f61d4a" title="Get access to the controlled entity.">getTarget</a> </dd></dl>

</div>
</div>
<a id="a8a29c1e5ea9348913794d21428197b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a29c1e5ea9348913794d21428197b13">&#9670;&nbsp;</a></span>onBorderCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onBorderCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a grid border collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target tries to go beyond the bounds of the grid. By default the event is handled internally before it's emitted to the outside. The internal handler prevents the target from leaving the grid. That is, the target will occupy the same tile it occupied before the collision. This behaviour is not removable, however, it may be overridden since the internal handler is called first before alerting external handlers</p>
<dl class="section see"><dt>See also</dt><dd>unsubscribe </dd></dl>

</div>
</div>
<a id="a13cca84e762939e48b6949d0aa87e571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cca84e762939e48b6949d0aa87e571">&#9670;&nbsp;</a></span>onDestruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onDestruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a destruction listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to be executed when the object is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the destruction listener</dd></dl>
<p>The destruction listener is called when the object reaches the end of its lifetime. Note that an object may have multiple destruction listeners registered to it</p>
<dl class="section warning"><dt>Warning</dt><dd>It's not advised to call virtual functions in the destruction callback as some parts of the object may have already been destroyed by the time the callback is invoked. In such an event, the behavior is undefined</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#a62658e4b24f61452ae7308f8bdf23994" title="Remove an event listener from an event.">removeEventListener</a> </dd></dl>

</div>
</div>
<a id="aa54c01c573b9b968117a0b5ef0fd8618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54c01c573b9b968117a0b5ef0fd8618">&#9670;&nbsp;</a></span>onDirectionChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onDirectionChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a target direction change. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when target direction changes </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners unique identifier</dd></dl>
<p>The direction change event is triggered by a move request</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a82d5a2809795725446f88f0ed90f4c71" title="Request a move in a given direction.">requestMove</a> </dd></dl>

</div>
</div>
<a id="aa8181e77c50a31a9200e7f64120144ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8181e77c50a31a9200e7f64120144ec">&#9670;&nbsp;</a></span>onMoveBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onMoveBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a move begin event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when the game object starts moving </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners unique identification number</dd></dl>
<p>This event is emitted when the game object starts moving from its current tile to one of its adjacent tile. The callback is passed the index of the tile that the game object is currently moving to</p>
<dl class="section note"><dt>Note</dt><dd>When controlled by a grid mover, the game object will always move one tile at a time, regardless of how fast it's moving</dd></dl>
<dl class="section see"><dt>See also</dt><dd>onAdjacentMoveEnd </dd></dl>

</div>
</div>
<a id="a37f1bbb0367901e3f8b79dfb4d764e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f1bbb0367901e3f8b79dfb4d764e8e">&#9670;&nbsp;</a></span>onMoveEnd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onMoveEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to an adjacent tile reached event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target reaches its target tile </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target moves from its current tile to any of its adjacent tiles.</p>
<dl class="section note"><dt>Note</dt><dd>When controlled by a grid mover, the target will always move one tile at a time, regardless of how fast the target is moving</dd></dl>
<p>The callback is passed the index of the tile the target moved to</p>
<dl class="section see"><dt>See also</dt><dd>onAdjacentMoveBegin </dd></dl>

</div>
</div>
<a id="ae56a395c13ead1ca472909d9d1f77993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56a395c13ead1ca472909d9d1f77993">&#9670;&nbsp;</a></span>onObjectCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onObjectCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_grid_object.html">GridObject</a> *, <a class="el" href="classime_1_1_grid_object.html">GridObject</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a grid collision event event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when the target collides with another game object </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners unique identification number </dd></dl>

</div>
</div>
<a id="a50e4e9783f6eb2de80ae33435381f453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e4e9783f6eb2de80ae33435381f453">&#9670;&nbsp;</a></span>onPropertyChange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to any property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when any property changes </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the event listener</dd></dl>
<p>When unsubscribing the any property change event handler, you must pass <em>"propertyChange"</em> as the name of the event</p>
<dl class="section see"><dt>See also</dt><dd>onPropertyChange(const std::string&amp;, const ime::Callback&lt;ime::Property&gt;&amp;) </dd></dl>

</div>
</div>
<a id="a0a5d4f512ca54743a3d5ab21c2022050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5d4f512ca54743a3d5ab21c2022050">&#9670;&nbsp;</a></span>onPropertyChange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a specific property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to add an event listener to </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be executed when the property changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the event listener</dd></dl>
<p>A property change event is triggered by any function that begins with <em>set</em>, where the the text after <em>set</em> is the name of the property. For example, the <em><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag()</a></em> function, modifies the <em>tag</em> property of the object, thus will generate a "tag" change event each time it is called</p>
<p>Note that multiple event listeners may be registered to the same property change event. In addition, when adding a property change event listener, the name of the property must be in lowercase.</p>
<div class="fragment"><div class="line"><span class="comment">// Prints the tag of the player object to the console everytime it changes</span></div>
<div class="line">player.onPropertyChange(<span class="stringliteral">&quot;tag&quot;</span>, [](<span class="keyword">const</span> Property&amp; property) {</div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;New tag: &quot;</span> &lt;&lt;  <span class="keyword">property</span>.getValue&lt;std::string&gt;() &lt;&lt; endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"><span class="comment">//Sets tag = &quot;player1&quot; and invokes event listener(s)</span></div>
<div class="line">player.setTag(<span class="stringliteral">&quot;player1&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>unsubscribe and onPropertyChange(const ime::Callback&lt;ime::Property&gt;&amp;) </dd></dl>

</div>
</div>
<a id="a77f61b75e33ec1e8ef9a3da3076938d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f61b75e33ec1e8ef9a3da3076938d0">&#9670;&nbsp;</a></span>onTargetTileReset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onTargetTileReset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to target tile reset event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target tile is reset </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ade350b65cfb3791254d942550882b895" title="Reset the target tile to be the same as the entity tile.">resetTargetTile</a> and unsubscribe </dd></dl>

</div>
</div>
<a id="a6a0ec54bb9214803536761cc7cd9a18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0ec54bb9214803536761cc7cd9a18a">&#9670;&nbsp;</a></span>onTileCollision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onTileCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>oneTime</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a tile collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
    <tr><td class="paramname">oneTime</td><td>True to execute the callback one-time or false to execute it every time the event is triggered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with a solid tile in the grid (Solid tiles are always collidable). By default, the event is handled internally before its emitted to the outside. The internal handler prevents the target from occupying the solid tile by moving it back to its previous tile after the collision</p>
<p>The callback is passed the index of the tile the target collided with</p>
<dl class="section see"><dt>See also</dt><dd>unsubscribe </dd></dl>

</div>
</div>
<a id="a981cd5ffbdec5adb244730b0da55131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981cd5ffbdec5adb244730b0da55131d">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_mover.html">GridMover</a>&amp; ime::GridMover::operator= </td>
          <td>(</td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>GridMover</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a62658e4b24f61452ae7308f8bdf23994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62658e4b24f61452ae7308f8bdf23994">&#9670;&nbsp;</a></span>removeEventListener() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::removeEventListener </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an event listener from an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The name of the event to remove an event listener from </td></tr>
    <tr><td class="paramname">id</td><td>The unique id of the event listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the event listener was removed or false if the event or the event listener is does not exist</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Display the tag of the object to console every time it changes</span></div>
<div class="line"><span class="keyword">auto</span> tagChangeId = <span class="keywordtype">object</span>.onPropertyChange(<span class="stringliteral">&quot;tag&quot;</span>, [](<a class="code" href="classime_1_1_property.html">ime::Property</a> tag) {</div>
<div class="line">     std::cout &lt;&lt; name.getValue&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop displaying the tag of the object when it changes</span></div>
<div class="line"><span class="keywordtype">object</span>.removeEventListener(<span class="stringliteral">&quot;tag&quot;</span>, tagChangeId);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a33f5fcb279d0bd9f58faffe663d19554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f5fcb279d0bd9f58faffe663d19554">&#9670;&nbsp;</a></span>removeEventListener() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::removeEventListener </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an event listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the event listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the event listener was removed or false if no such handler exists </dd></dl>

</div>
</div>
<a id="a82d5a2809795725446f88f0ed90f4c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d5a2809795725446f88f0ed90f4c71">&#9670;&nbsp;</a></span>requestMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::requestMove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request a move in a given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>The direction to move in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the move was granted or false if the target is currently moving to another tile</dd></dl>
<p>The target can only move one tile at a time, as a result it cannot be requested to move to a tile while it is currently moving towards another tile (see <a class="el" href="classime_1_1_grid_mover.html#af2f703bf9dfc0c91c76716dac3ded84a" title="Check if target is moving or not.">isTargetMoving()</a>). In addition, If a move in the specified direction is possible, the adjacent tile in the specified direction will be flagged as occupied by the target before it moves to it </p>

</div>
</div>
<a id="ade350b65cfb3791254d942550882b895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade350b65cfb3791254d942550882b895">&#9670;&nbsp;</a></span>resetTargetTile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::resetTargetTile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the target tile to be the same as the entity tile. </p>
<dl class="section note"><dt>Note</dt><dd>This function must be called every time the target is manually moved in the grid so that the grid mover can register the new position of the target. If not called, the <a class="el" href="classime_1_1_grid_mover.html" title="Class for performing grid based movement on an entity in a grid.">GridMover</a> will lose control of the target and the targets movement behavior is undefined in such a case. In addition, note that the target tile can only be reset when the target is not moving. Here's an example:</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Let the grid mover be responsible for moving the player object</span></div>
<div class="line">grid.addChild(player, <a class="code" href="structime_1_1_index.html">ime::Index</a>{4, 5});</div>
<div class="line">gridMover.setTarget(player);</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Manually move the player to some desired position</span></div>
<div class="line">if (!gridMover.isTargetMoving) {</div>
<div class="line">    gridMover.getGrid().removeChild(player);</div>
<div class="line">    gridMover.getGrid().addChild(player, <a class="code" href="structime_1_1_index.html">ime::Index</a>{11, 20});</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Let the grid mover know that the player is no longer where it</span></div>
<div class="line">     <span class="comment">// was registered to be (The grid mover will update itself accordingly)</span></div>
<div class="line">     gridMover.resetTargetTile();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2a264750eeefd2cacf760ad9d785d3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a264750eeefd2cacf760ad9d785d3a7">&#9670;&nbsp;</a></span>setMovementFreeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setMovementFreeze </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeze</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Freeze or unfreeze the targets movement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freeze</td><td>True to freeze movement or false to unfreeze</td></tr>
  </table>
  </dd>
</dl>
<p>This function achieves the same thing as <a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b" title="Restrict the movement of the game object to certain directions.">setMovementRestriction()</a>. The difference is when the function is called while the target is moving. setMovementRestriction(true) will prevent the target from moving further after the targets gets to its targeted tile whilst setMovementFreeze(true) will immediately prevent the target from moving further. This means that the target can temporarily be in between grid tiles</p>
<p>By default, the targets movement is not frozen</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b" title="Restrict the movement of the game object to certain directions.">setMovementRestriction</a> </dd></dl>

</div>
</div>
<a id="a121bf39232196e459b0c0b619e963c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121bf39232196e459b0c0b619e963c7b">&#9670;&nbsp;</a></span>setMovementRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setMovementRestriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a>&#160;</td>
          <td class="paramname"><em>moveRestriction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restrict the movement of the game object to certain directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moveRestriction</td><td>Permitted direction of travel</td></tr>
  </table>
  </dd>
</dl>
<p>By default the movement restrictions is MovementRestriction::None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7" title="Freeze or unfreeze the targets movement.">setMovementFreeze</a> </dd></dl>

</div>
</div>
<a id="ada3898f9de6562ae8ff0ab9a6b7c813f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3898f9de6562ae8ff0ab9a6b7c813f">&#9670;&nbsp;</a></span>setSpeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setSpeed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> &amp;&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the speed of the game object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The new speed</td></tr>
  </table>
  </dd>
</dl>
<p>If the game object is currently moving, the speed will be set after it reaches its current target tile</p>
<p>Note that for a ime::MoveRestriction::Diagonal or ime::MoveRestriction::None, the speed must be the same for both the x and y axis, otherwise undefined behaviour</p>
<p>By default, the speed is <a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065" title="2D float vector">ime::Vector2f</a>{60, 60}</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a6d91709a02eb517e68edb798949bd91d" title="Get the speed of the target.">getSpeed</a> </dd></dl>

</div>
</div>
<a id="a3a9c1ee303df652a29e07ac33ecb00b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9c1ee303df652a29e07ac33ecb00b7">&#9670;&nbsp;</a></span>setSpeedMultiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setSpeedMultiplier </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>multiplier</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a speed multiplier. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiplier</td><td>The new speed multiplier</td></tr>
  </table>
  </dd>
</dl>
<p>A speed multiplier increases or decreases the speed of the target without affecting its default speed. For example, A multiplier of 2.0f makes the target move twice as fast, a multiplier of 0.5f makes the target move at half its normal speed and a multiplier of 0.0f stops the target from moving. Note that a negative multiplier will be ignored</p>
<p>By default, the multiplier is 1.0f (normal)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#acf2934181430189656188257bd77ed5b" title="Get the speed multiplier.">getSpeedMultiplier</a> </dd></dl>

</div>
</div>
<a id="aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">&#9670;&nbsp;</a></span>setTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::setTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the object an alias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The alias of the object</td></tr>
  </table>
  </dd>
</dl>
<p>This function is useful if you want to refer to the object by a tag instead of its object id. Unlike an object id, multiple objects may have the same tag</p>
<p>By default, the tag is an empty string</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af" title="Get the unique id of the object.">getObjectId</a> </dd></dl>

</div>
</div>
<a id="a2b8a2eb07cdf61592f63a32e8e88436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8a2eb07cdf61592f63a32e8e88436f">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_object.html">GridObject</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the controlled entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>New target</td></tr>
  </table>
  </dd>
</dl>
<p>Provide nullptr as argument to remove current target</p>
<dl class="section warning"><dt>Warning</dt><dd>if the <em>target</em> is not a <em>nullptr</em>, then it must exist in the <a class="el" href="classime_1_1_grid2_d.html" title="A 2D visual grid.">Grid2D</a> and must not have a <a class="el" href="classime_1_1_rigid_body.html" title="A rigid body.">RigidBody</a> attached to it, otherwise undefined behavior </dd></dl>

</div>
</div>
<a id="aad38f902db7325b4898fdbe2830ef898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad38f902db7325b4898fdbe2830ef898">&#9670;&nbsp;</a></span>suspendedEventListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::suspendedEventListener </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suspend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pause or resume execution of an event listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The event listeners unique identification number </td></tr>
    <tr><td class="paramname">suspend</td><td>True to suspend/pause or false to unsuspend/resume</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#acedadb2161e63cb84f2964e3e4b03b4f" title="Check if an event listener is suspended or not.">isEventListenerSuspended</a> </dd></dl>

</div>
</div>
<a id="a0627539f4f7e59a9905c4d9d37396089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0627539f4f7e59a9905c4d9d37396089">&#9670;&nbsp;</a></span>syncWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::syncWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_grid_mover.html">GridMover</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sync this grid mover with another grid mover. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The grid mover to sync with this grid mover with</td></tr>
  </table>
  </dd>
</dl>
<p>In situations where you want to change a targets grid mover, you'll have to synchronize the new grid mover with the current grid mover to avoid misalignment with the grid. When misaligned, the target is no longer confined to the grid and moves indefinitely in its current direction. Note that misalignment does not occur when the target is not moving, i.e when isMoving() returns false.</p>
<div class="fragment"><div class="line"><span class="comment">// Lets assume a player target was being moved by a ime::RandomGridMover</span></div>
<div class="line"><span class="comment">// and now we want it to be moved by a ime::CyclicGridMover</span></div>
<div class="line">cyclicGridMover.sync(randomGridMover);</div>
<div class="line">cyclicGridMover.setTarget(randomGridMover.getTarget());</div>
<div class="line">randomGridMover.setTarget(<span class="keyword">nullptr</span>);</div>
<div class="line">cyclicGridMover.startMovement();</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1861b96d89d9bc4539eda2cdacd356b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1861b96d89d9bc4539eda2cdacd356b8">&#9670;&nbsp;</a></span>teleportTargetToDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::teleportTargetToDestination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Force the target to reach it's destination. </p>
<p>The destination in this context is always the adjacent tile the target is headed towards. This function has no effect if the target is not moving towards any tile </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a805a30e8835e41133a4bdbfbed2e1b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805a30e8835e41133a4bdbfbed2e1b52">&#9670;&nbsp;</a></span>eventEmitter_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_event_emitter.html">EventEmitter</a> ime::Object::eventEmitter_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classime_1_1_event.html" title="Defines a system event and its parameters.">Event</a> dispatcher. </p>

<p class="definition">Definition at line <a class="el" href="_object_8h_source.html#l00278">278</a> of file <a class="el" href="_object_8h_source.html">Object.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_grid_mover_8h_source.html">GridMover.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassime_1_1_property_html"><div class="ttname"><a href="classime_1_1_property.html">ime::Property</a></div><div class="ttdoc">Class that can store a value of any type.</div><div class="ttdef"><b>Definition:</b> <a href="_property_8h_source.html#l00038">Property.h:38</a></div></div>
<div class="ttc" id="astructime_1_1_index_html"><div class="ttname"><a href="structime_1_1_index.html">ime::Index</a></div><div class="ttdoc">Represents a position Grid2D Tile.</div><div class="ttdef"><b>Definition:</b> <a href="_index_8h_source.html#l00035">Index.h:35</a></div></div>
        </div>
        <div id="footer-container">
            <div id="footer">
                IME is licensed under the terms and conditions of the <a href="https://github.com/KwenaMashamaite/IME/blob/master/LICENSE">MIT license</a>.<br>
                Copyright &copy; 2020-2022 Kwena Mashamaite
            </div>
        </div>
    </body>
</html>
