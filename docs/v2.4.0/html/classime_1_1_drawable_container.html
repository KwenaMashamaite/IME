<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>IME - Infinite Motion Engine</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="ime">Documentation of IME 2.4.0</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.20 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceime.html">ime</a></li><li class="navelem"><a class="el" href="classime_1_1_drawable_container.html">DrawableContainer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classime_1_1_drawable_container-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ime::DrawableContainer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A container for <a class="el" href="classime_1_1_drawable.html" title="Interface for drawable objects.">Drawable</a> objects.  
 <a href="classime_1_1_drawable_container.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_drawable_container_8h_source.html">DrawableContainer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ime::DrawableContainer&lt; T &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classime_1_1_drawable_container.png" usemap="#ime::DrawableContainer_3C_20T_20_3E_map" alt=""/>
  <map id="ime::DrawableContainer_3C_20T_20_3E_map" name="ime::DrawableContainer_3C_20T_20_3E_map">
<area href="classime_1_1_object_container.html" title="A container for ime::Object instances." alt="ime::ObjectContainer&lt; T &gt;" shape="rect" coords="0,0,177,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae027bfc00fd139103849934bde296ede"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae027bfc00fd139103849934bde296ede"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a> = std::function&lt; void(Args...)&gt;</td></tr>
<tr class="memdesc:ae027bfc00fd139103849934bde296ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each callback.  <a href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">More...</a><br /></td></tr>
<tr class="separator:ae027bfc00fd139103849934bde296ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7510136cf7c452265d68aeac0f2615"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> = std::function&lt; bool(const T *)&gt;</td></tr>
<tr class="memdesc:aab7510136cf7c452265d68aeac0f2615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate callback.  <a href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">More...</a><br /></td></tr>
<tr class="separator:aab7510136cf7c452265d68aeac0f2615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ae3d51bd034b26d8e7b857f62a5a55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#aa5ae3d51bd034b26d8e7b857f62a5a55">ObjectPtr</a> = std::unique_ptr&lt; T &gt;</td></tr>
<tr class="memdesc:aa5ae3d51bd034b26d8e7b857f62a5a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> pointer.  <a href="classime_1_1_object_container.html#aa5ae3d51bd034b26d8e7b857f62a5a55">More...</a><br /></td></tr>
<tr class="separator:aa5ae3d51bd034b26d8e7b857f62a5a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0dc76b523e152f18018a30d6981670ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_drawable_container.html#a0dc76b523e152f18018a30d6981670ff">DrawableContainer</a> (<a class="el" href="classime_1_1_render_layer_container.html">RenderLayerContainer</a> &amp;renderLayers)</td></tr>
<tr class="memdesc:a0dc76b523e152f18018a30d6981670ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classime_1_1_drawable_container.html#a0dc76b523e152f18018a30d6981670ff">More...</a><br /></td></tr>
<tr class="separator:a0dc76b523e152f18018a30d6981670ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8628d5c1eeeac22e4fbdc23f46f54ad"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_drawable_container.html#aa8628d5c1eeeac22e4fbdc23f46f54ad">add</a> (std::unique_ptr&lt; T &gt; drawable, int renderOrder=0u, const std::string &amp;renderLayer=&quot;default&quot;)</td></tr>
<tr class="memdesc:aa8628d5c1eeeac22e4fbdc23f46f54ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a drawable object to the container.  <a href="classime_1_1_drawable_container.html#aa8628d5c1eeeac22e4fbdc23f46f54ad">More...</a><br /></td></tr>
<tr class="separator:aa8628d5c1eeeac22e4fbdc23f46f54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fac8243327b97e4baea47e5528a006"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#af7fac8243327b97e4baea47e5528a006">addObject</a> (<a class="el" href="classime_1_1_object_container.html#aa5ae3d51bd034b26d8e7b857f62a5a55">ObjectPtr</a> object, const std::string &amp;group=&quot;none&quot;)</td></tr>
<tr class="memdesc:af7fac8243327b97e4baea47e5528a006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an object to the container.  <a href="classime_1_1_object_container.html#af7fac8243327b97e4baea47e5528a006">More...</a><br /></td></tr>
<tr class="separator:af7fac8243327b97e4baea47e5528a006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e46a10f020a21343f16b17a4f968e0c"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a2e46a10f020a21343f16b17a4f968e0c">findByTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a2e46a10f020a21343f16b17a4f968e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object with a given tag.  <a href="classime_1_1_object_container.html#a2e46a10f020a21343f16b17a4f968e0c">More...</a><br /></td></tr>
<tr class="separator:a2e46a10f020a21343f16b17a4f968e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b84e4c82434ff11da0ed4ea03c7903"><td class="memItemLeft" align="right" valign="top"><a id="a42b84e4c82434ff11da0ed4ea03c7903"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>findByTag</b> (const std::string &amp;tag) const</td></tr>
<tr class="separator:a42b84e4c82434ff11da0ed4ea03c7903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9881b0537079eb48b07b7a1df0d2baad"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a9881b0537079eb48b07b7a1df0d2baad"><td class="memTemplItemLeft" align="right" valign="top">U *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a9881b0537079eb48b07b7a1df0d2baad">findByTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:a9881b0537079eb48b07b7a1df0d2baad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object with a given tag.  <a href="classime_1_1_object_container.html#a9881b0537079eb48b07b7a1df0d2baad">More...</a><br /></td></tr>
<tr class="separator:a9881b0537079eb48b07b7a1df0d2baad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8c73d7a145d635426f9eedcf3321a2"><td class="memTemplParams" colspan="2"><a id="acf8c73d7a145d635426f9eedcf3321a2"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:acf8c73d7a145d635426f9eedcf3321a2"><td class="memTemplItemLeft" align="right" valign="top">const U *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findByTag</b> (const std::string &amp;tag) const</td></tr>
<tr class="separator:acf8c73d7a145d635426f9eedcf3321a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d6369c75c11ea680638b57d6922a72"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a13d6369c75c11ea680638b57d6922a72">findById</a> (unsigned int id)</td></tr>
<tr class="memdesc:a13d6369c75c11ea680638b57d6922a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object with the given id.  <a href="classime_1_1_object_container.html#a13d6369c75c11ea680638b57d6922a72">More...</a><br /></td></tr>
<tr class="separator:a13d6369c75c11ea680638b57d6922a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdce24e1552ec1ccfca201ad290891a1"><td class="memItemLeft" align="right" valign="top"><a id="abdce24e1552ec1ccfca201ad290891a1"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>findById</b> (unsigned int id) const</td></tr>
<tr class="separator:abdce24e1552ec1ccfca201ad290891a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3afc05c6675aac6cc20a218015e542"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:add3afc05c6675aac6cc20a218015e542"><td class="memTemplItemLeft" align="right" valign="top">U *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#add3afc05c6675aac6cc20a218015e542">findById</a> (unsigned int id)</td></tr>
<tr class="memdesc:add3afc05c6675aac6cc20a218015e542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an object with the given id.  <a href="classime_1_1_object_container.html#add3afc05c6675aac6cc20a218015e542">More...</a><br /></td></tr>
<tr class="separator:add3afc05c6675aac6cc20a218015e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6245e9b93179abba7cb86f5f64f00fac"><td class="memTemplParams" colspan="2"><a id="a6245e9b93179abba7cb86f5f64f00fac"></a>
template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6245e9b93179abba7cb86f5f64f00fac"><td class="memTemplItemLeft" align="right" valign="top">const U *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>findById</b> (unsigned int id) const</td></tr>
<tr class="separator:a6245e9b93179abba7cb86f5f64f00fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8845c3d878a185cc4d07768c69ed027b"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a8845c3d878a185cc4d07768c69ed027b">findIf</a> (const <a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> &amp;predicate)</td></tr>
<tr class="memdesc:a8845c3d878a185cc4d07768c69ed027b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally find an object in the container.  <a href="classime_1_1_object_container.html#a8845c3d878a185cc4d07768c69ed027b">More...</a><br /></td></tr>
<tr class="separator:a8845c3d878a185cc4d07768c69ed027b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dba664bd6d8f448c82bf93f192cda09"><td class="memItemLeft" align="right" valign="top"><a id="a8dba664bd6d8f448c82bf93f192cda09"></a>
const T *&#160;</td><td class="memItemRight" valign="bottom"><b>findIf</b> (const <a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> &amp;predicate) const</td></tr>
<tr class="separator:a8dba664bd6d8f448c82bf93f192cda09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55ca785fbfd6feb6408312803a5b1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#ad55ca785fbfd6feb6408312803a5b1a4">removeByTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:ad55ca785fbfd6feb6408312803a5b1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all objects with the given tag.  <a href="classime_1_1_object_container.html#ad55ca785fbfd6feb6408312803a5b1a4">More...</a><br /></td></tr>
<tr class="separator:ad55ca785fbfd6feb6408312803a5b1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26673a494a7b5265c6094e81583b37b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a26673a494a7b5265c6094e81583b37b4">removeById</a> (unsigned int id)</td></tr>
<tr class="memdesc:a26673a494a7b5265c6094e81583b37b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object with the given id.  <a href="classime_1_1_object_container.html#a26673a494a7b5265c6094e81583b37b4">More...</a><br /></td></tr>
<tr class="separator:a26673a494a7b5265c6094e81583b37b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258a49c10d0deac2345c78db5ab3ac9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a258a49c10d0deac2345c78db5ab3ac9c">remove</a> (T *object)</td></tr>
<tr class="memdesc:a258a49c10d0deac2345c78db5ab3ac9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from the container.  <a href="classime_1_1_object_container.html#a258a49c10d0deac2345c78db5ab3ac9c">More...</a><br /></td></tr>
<tr class="separator:a258a49c10d0deac2345c78db5ab3ac9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3eaf2bdab65f58c225b7aecd4879f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#af3eaf2bdab65f58c225b7aecd4879f84">removeIf</a> (const <a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> &amp;predicate)</td></tr>
<tr class="memdesc:af3eaf2bdab65f58c225b7aecd4879f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally remove objects from the container.  <a href="classime_1_1_object_container.html#af3eaf2bdab65f58c225b7aecd4879f84">More...</a><br /></td></tr>
<tr class="separator:af3eaf2bdab65f58c225b7aecd4879f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5913d605d157e07cfb1b1851d0cf903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#aa5913d605d157e07cfb1b1851d0cf903">removeAll</a> ()</td></tr>
<tr class="memdesc:aa5913d605d157e07cfb1b1851d0cf903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all objects from the container.  <a href="classime_1_1_object_container.html#aa5913d605d157e07cfb1b1851d0cf903">More...</a><br /></td></tr>
<tr class="separator:aa5913d605d157e07cfb1b1851d0cf903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b9a6116c166ce9a3ac513294888522"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#aa6b9a6116c166ce9a3ac513294888522">getCount</a> () const</td></tr>
<tr class="memdesc:aa6b9a6116c166ce9a3ac513294888522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of objects in the container.  <a href="classime_1_1_object_container.html#aa6b9a6116c166ce9a3ac513294888522">More...</a><br /></td></tr>
<tr class="separator:aa6b9a6116c166ce9a3ac513294888522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e94370d66299d7e57dfdc9a2b1187c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_object_container.html">ObjectContainer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c">createGroup</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a21e94370d66299d7e57dfdc9a2b1187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a group to add objects to.  <a href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c">More...</a><br /></td></tr>
<tr class="separator:a21e94370d66299d7e57dfdc9a2b1187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a6f15c8967a2c9914a3cfd6d35002c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_object_container.html">ObjectContainer</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#ae5a6f15c8967a2c9914a3cfd6d35002c">getGroup</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:ae5a6f15c8967a2c9914a3cfd6d35002c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a group in the container.  <a href="classime_1_1_object_container.html#ae5a6f15c8967a2c9914a3cfd6d35002c">More...</a><br /></td></tr>
<tr class="separator:ae5a6f15c8967a2c9914a3cfd6d35002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9cd5119bf65be01dc8083aad2c4d75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a9b9cd5119bf65be01dc8083aad2c4d75">hasGroup</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a9b9cd5119bf65be01dc8083aad2c4d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not the container has a given group.  <a href="classime_1_1_object_container.html#a9b9cd5119bf65be01dc8083aad2c4d75">More...</a><br /></td></tr>
<tr class="separator:a9b9cd5119bf65be01dc8083aad2c4d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df7f17e840f96fcc6313392af7365d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a5df7f17e840f96fcc6313392af7365d5">removeGroup</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a5df7f17e840f96fcc6313392af7365d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a group from the container.  <a href="classime_1_1_object_container.html#a5df7f17e840f96fcc6313392af7365d5">More...</a><br /></td></tr>
<tr class="separator:a5df7f17e840f96fcc6313392af7365d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4543480f98f131bf7421850bb32dbfdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a4543480f98f131bf7421850bb32dbfdb">removeAllGroups</a> ()</td></tr>
<tr class="memdesc:a4543480f98f131bf7421850bb32dbfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all groups from the container.  <a href="classime_1_1_object_container.html#a4543480f98f131bf7421850bb32dbfdb">More...</a><br /></td></tr>
<tr class="separator:a4543480f98f131bf7421850bb32dbfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e93114f2ccfa2ce16256e27837324c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a2e93114f2ccfa2ce16256e27837324c0">forEach</a> (const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;callback) const</td></tr>
<tr class="memdesc:a2e93114f2ccfa2ce16256e27837324c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a callback function to each object in the container.  <a href="classime_1_1_object_container.html#a2e93114f2ccfa2ce16256e27837324c0">More...</a><br /></td></tr>
<tr class="separator:a2e93114f2ccfa2ce16256e27837324c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5405235df37dc8aaf313e52fd164b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#a5c5405235df37dc8aaf313e52fd164b3">forEachInGroup</a> (const std::string &amp;name, const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;callback) const</td></tr>
<tr class="memdesc:a5c5405235df37dc8aaf313e52fd164b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a callback to each object in a specific group.  <a href="classime_1_1_object_container.html#a5c5405235df37dc8aaf313e52fd164b3">More...</a><br /></td></tr>
<tr class="separator:a5c5405235df37dc8aaf313e52fd164b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4160521ba9f9b945fbc82b45f4a29b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object_container.html#ab4160521ba9f9b945fbc82b45f4a29b9">forEachNotInGroup</a> (const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;callback) const</td></tr>
<tr class="memdesc:ab4160521ba9f9b945fbc82b45f4a29b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a callback to all objects that do not belong to a group.  <a href="classime_1_1_object_container.html#ab4160521ba9f9b945fbc82b45f4a29b9">More...</a><br /></td></tr>
<tr class="separator:ab4160521ba9f9b945fbc82b45f4a29b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class ime::DrawableContainer&lt; T &gt;</h3>

<p>A container for <a class="el" href="classime_1_1_drawable.html" title="Interface for drawable objects.">Drawable</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="_drawable_container_8h_source.html#l00037">37</a> of file <a class="el" href="_drawable_container_8h_source.html">DrawableContainer.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae027bfc00fd139103849934bde296ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae027bfc00fd139103849934bde296ede">&#9670;&nbsp;</a></span>Callback</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::<a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a> =  std::function&lt;void(Args...)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For each callback. </p>

<p class="definition">Definition at line <a class="el" href="_object_container_8h_source.html#l00044">44</a> of file <a class="el" href="_object_container_8h_source.html">ObjectContainer.h</a>.</p>

</div>
</div>
<a id="aa5ae3d51bd034b26d8e7b857f62a5a55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ae3d51bd034b26d8e7b857f62a5a55">&#9670;&nbsp;</a></span>ObjectPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::<a class="el" href="classime_1_1_object_container.html#aa5ae3d51bd034b26d8e7b857f62a5a55">ObjectPtr</a> =  std::unique_ptr&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unique <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> pointer. </p>

<p class="definition">Definition at line <a class="el" href="_object_container_8h_source.html#l00047">47</a> of file <a class="el" href="_object_container_8h_source.html">ObjectContainer.h</a>.</p>

</div>
</div>
<a id="aab7510136cf7c452265d68aeac0f2615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab7510136cf7c452265d68aeac0f2615">&#9670;&nbsp;</a></span>Predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::<a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> =  std::function&lt;bool(const T*)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Predicate callback. </p>

<p class="definition">Definition at line <a class="el" href="_object_container_8h_source.html#l00046">46</a> of file <a class="el" href="_object_container_8h_source.html">ObjectContainer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0dc76b523e152f18018a30d6981670ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc76b523e152f18018a30d6981670ff">&#9670;&nbsp;</a></span>DrawableContainer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_drawable_container.html">ime::DrawableContainer</a>&lt; T &gt;::<a class="el" href="classime_1_1_drawable_container.html">DrawableContainer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_render_layer_container.html">RenderLayerContainer</a> &amp;&#160;</td>
          <td class="paramname"><em>renderLayers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderLayers</td><td>The render layer container for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa8628d5c1eeeac22e4fbdc23f46f54ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8628d5c1eeeac22e4fbdc23f46f54ad">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classime_1_1_drawable_container.html">ime::DrawableContainer</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>renderOrder</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>renderLayer</em> = <code>&quot;default&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a drawable object to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>The drawable object to be added </td></tr>
    <tr><td class="paramname">renderOrder</td><td>The render order of the object in the render layer </td></tr>
    <tr><td class="paramname">renderLayer</td><td>The <a class="el" href="classime_1_1_render_layer.html" title="A layer for drawable entities.">RenderLayer</a> the object belongs to</td></tr>
  </table>
  </dd>
</dl>
<p>If the render layer is unspecified or the specified layer cannot be found then the drawable will be added to the 'default' layer. The 'default' render layer is created by the <a class="el" href="classime_1_1_scene.html" title="An Abstract Base Class (ABC) for game scenes.">Scene</a> when you instantiate it. Note that the 'default' layer may be deleted from the scenes render layers, however you must make sure that the layer you specify during a call to this function already exists otherwise undefined behavior </p>

</div>
</div>
<a id="af7fac8243327b97e4baea47e5528a006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fac8243327b97e4baea47e5528a006">&#9670;&nbsp;</a></span>addObject()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::addObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_object_container.html#aa5ae3d51bd034b26d8e7b857f62a5a55">ObjectPtr</a>&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em> = <code>&quot;none&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an object to the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The object to be added </td></tr>
    <tr><td class="paramname">group</td><td>The name of the group to add the object to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the object after its added to the container</dd></dl>
<p>If the <em>group</em> is not found, it will be created and the <em>object</em> will be the first member of it. Groups are useful if you want to refer to objects that are the same or similar as a whole</p>
<p>By default the object does not belong to any group</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c" title="Create a group to add objects to.">createGroup</a> </dd></dl>

</div>
</div>
<a id="a21e94370d66299d7e57dfdc9a2b1187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e94370d66299d7e57dfdc9a2b1187c">&#9670;&nbsp;</a></span>createGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_object_container.html">ObjectContainer</a>&lt;T&gt;&amp; <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::createGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a group to add objects to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created group</dd></dl>
<p>This function is useful if you want to relate some objects and refer to them as a whole using a common group name instead of using a common tag name and looping though the container to find which objects have a given tag. Note that the name of the group must be unique</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> weapons = objectContainer.createGroup(<span class="stringliteral">&quot;weapons&quot;</span>);</div>
<div class="line">weapons.addObject(knife);</div>
<div class="line">weapons.addObject(machete);</div>
<div class="line">weapons.addObject(bat);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#af7fac8243327b97e4baea47e5528a006" title="Add an object to the container.">addObject</a> </dd></dl>

</div>
</div>
<a id="a13d6369c75c11ea680638b57d6922a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d6369c75c11ea680638b57d6922a72">&#9670;&nbsp;</a></span>findById() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::findById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object with the given id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object with the given id or a nullptr if the object could not be found in the container </dd></dl>

</div>
</div>
<a id="add3afc05c6675aac6cc20a218015e542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add3afc05c6675aac6cc20a218015e542">&#9670;&nbsp;</a></span>findById() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::findById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object with the given id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object to be retrieved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object with the given id or a nullptr if the object could not be found in the container or the the object is found but it is not convertible to type U</dd></dl>
<p>You can use this function to get the derived class type U if T is a base class</p>
<div class="fragment"><div class="line"><span class="comment">// The type of rectangle is ime::Shape*</span></div>
<div class="line"><span class="keyword">auto</span> rectangle = shapeContainer.findById(4);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The type of rectangle2 is ime::RectangleShape*</span></div>
<div class="line"><span class="keyword">auto</span> rectangle2 = shapeContainer.findById&lt;<a class="code" href="classime_1_1_rectangle_shape.html">ime::RectangleShape</a>&gt;(4);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2e46a10f020a21343f16b17a4f968e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e46a10f020a21343f16b17a4f968e0c">&#9670;&nbsp;</a></span>findByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::findByTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object with a given tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag of the object to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object with the given tag or a nullptr if the object could not be found in the container</dd></dl>
<p>Note that this function will return the first object it finds with the the given tag if the container has multiple objects with the same tag </p>

</div>
</div>
<a id="a9881b0537079eb48b07b7a1df0d2baad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9881b0537079eb48b07b7a1df0d2baad">&#9670;&nbsp;</a></span>findByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::findByTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an object with a given tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag of the object to be searched </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object with the given tag or a nullptr if the object could not be found in the container or the the object is found but it is not convertible to type U</dd></dl>
<p>Note that this function will return the first object it finds with the the given tag if the container has multiple objects with the same tag. You can use this function to get the derived class type U if T is a base class:</p>
<div class="fragment"><div class="line"><span class="comment">// The type of rectangle is ime::Shape*</span></div>
<div class="line"><span class="keyword">auto</span>* rectangle = shapeContainer.findByTag(<span class="stringliteral">&quot;myRect&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The type of rectangle2 is ime::RectangleShape*</span></div>
<div class="line"><span class="keyword">auto</span>* rectangle2 = shapeContainer.findByTag&lt;<a class="code" href="classime_1_1_rectangle_shape.html">ime::RectangleShape</a>&gt;(<span class="stringliteral">&quot;myRect&quot;</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8845c3d878a185cc4d07768c69ed027b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8845c3d878a185cc4d07768c69ed027b">&#9670;&nbsp;</a></span>findIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::findIf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally find an object in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function which returns true if the object should be returned or false if the search should continue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The object that matches the found condition or a nullptr if an object that matches the success condition could not be found in the container </dd></dl>

</div>
</div>
<a id="a2e93114f2ccfa2ce16256e27837324c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e93114f2ccfa2ce16256e27837324c0">&#9670;&nbsp;</a></span>forEach()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::forEach </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a callback function to each object in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be applied to each object</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the callback is applied to all objects, this includes those that are assigned to groups</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a5c5405235df37dc8aaf313e52fd164b3" title="Apply a callback to each object in a specific group.">forEachInGroup</a> and <a class="el" href="classime_1_1_object_container.html#ab4160521ba9f9b945fbc82b45f4a29b9" title="Apply a callback to all objects that do not belong to a group.">forEachNotInGroup</a> </dd></dl>

</div>
</div>
<a id="a5c5405235df37dc8aaf313e52fd164b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5405235df37dc8aaf313e52fd164b3">&#9670;&nbsp;</a></span>forEachInGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::forEachInGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a callback to each object in a specific group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the group to apply callback on </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be applied to each object in the group</td></tr>
  </table>
  </dd>
</dl>
<p>This function is a shortcut for:</p>
<div class="fragment"><div class="line"><span class="comment">// It&#39;s undefined behaviour to call getGroup if the group does not exist</span></div>
<div class="line"><span class="keywordflow">if</span> (container.hasGroup(name)) {</div>
<div class="line">    container.getGroup(name)-&gt;forEach(...);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a2e93114f2ccfa2ce16256e27837324c0" title="Apply a callback function to each object in the container.">forEach</a> and <a class="el" href="classime_1_1_object_container.html#ab4160521ba9f9b945fbc82b45f4a29b9" title="Apply a callback to all objects that do not belong to a group.">forEachNotInGroup</a> </dd></dl>

</div>
</div>
<a id="ab4160521ba9f9b945fbc82b45f4a29b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4160521ba9f9b945fbc82b45f4a29b9">&#9670;&nbsp;</a></span>forEachNotInGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::forEachNotInGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object_container.html#ae027bfc00fd139103849934bde296ede">Callback</a>&lt; T * &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a callback to all objects that do not belong to a group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be applied to each object in the container that does not belong to any group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a2e93114f2ccfa2ce16256e27837324c0" title="Apply a callback function to each object in the container.">forEach</a> and <a class="el" href="classime_1_1_object_container.html#a5c5405235df37dc8aaf313e52fd164b3" title="Apply a callback to each object in a specific group.">forEachInGroup</a> </dd></dl>

</div>
</div>
<a id="aa6b9a6116c166ce9a3ac513294888522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b9a6116c166ce9a3ac513294888522">&#9670;&nbsp;</a></span>getCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::getCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of objects in the container. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of objects in the container </dd></dl>

</div>
</div>
<a id="ae5a6f15c8967a2c9914a3cfd6d35002c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a6f15c8967a2c9914a3cfd6d35002c">&#9670;&nbsp;</a></span>getGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_object_container.html">ObjectContainer</a>&lt;T&gt;&amp; <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::getGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a group in the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the group </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested group</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The specified group must exist in the container before this function is called otherwise undefined behavior</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c" title="Create a group to add objects to.">createGroup</a> and <a class="el" href="classime_1_1_object_container.html#a9b9cd5119bf65be01dc8083aad2c4d75" title="Check whether or not the container has a given group.">hasGroup</a> </dd></dl>

</div>
</div>
<a id="a9b9cd5119bf65be01dc8083aad2c4d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9cd5119bf65be01dc8083aad2c4d75">&#9670;&nbsp;</a></span>hasGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::hasGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether or not the container has a given group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the group to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the container has the specified group, otherwise false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c" title="Create a group to add objects to.">createGroup</a> </dd></dl>

</div>
</div>
<a id="a258a49c10d0deac2345c78db5ab3ac9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258a49c10d0deac2345c78db5ab3ac9c">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an object from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The object to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object was removed or false if the object does not exist in the container</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The argument must not be a nullptr </dd></dl>

</div>
</div>
<a id="aa5913d605d157e07cfb1b1851d0cf903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5913d605d157e07cfb1b1851d0cf903">&#9670;&nbsp;</a></span>removeAll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all objects from the container. </p>
<dl class="section warning"><dt>Warning</dt><dd>This function will invalidate any pointer(s) to the objects once they are removed from the container </dd></dl>

</div>
</div>
<a id="a4543480f98f131bf7421850bb32dbfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4543480f98f131bf7421850bb32dbfdb">&#9670;&nbsp;</a></span>removeAllGroups()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeAllGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all groups from the container. </p>
<p>This function will remove all objects that belong to a group from the container, leaving only objects that do not belong to a group if any. Note that pointers to the removed objects will be invalidated</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a5df7f17e840f96fcc6313392af7365d5" title="Remove a group from the container.">removeGroup</a> </dd></dl>

</div>
</div>
<a id="a26673a494a7b5265c6094e81583b37b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26673a494a7b5265c6094e81583b37b4">&#9670;&nbsp;</a></span>removeById()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeById </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an object with the given id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the object to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will invalidate any pointer(s) to the object once it is removed from the container </dd></dl>

</div>
</div>
<a id="ad55ca785fbfd6feb6408312803a5b1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55ca785fbfd6feb6408312803a5b1a4">&#9670;&nbsp;</a></span>removeByTag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeByTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all objects with the given tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag of the objects to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will invalidate any pointer(s) to the object once it is removed from the container </dd></dl>

</div>
</div>
<a id="a5df7f17e840f96fcc6313392af7365d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df7f17e840f96fcc6313392af7365d5">&#9670;&nbsp;</a></span>removeGroup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a group from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the group to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the group was removed or false if the specified group does not exist in the container</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will remove all objects in the given group from the container, therefore any pointers to the objects will be invalidated</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object_container.html#a21e94370d66299d7e57dfdc9a2b1187c" title="Create a group to add objects to.">createGroup</a> and <a class="el" href="classime_1_1_object_container.html#a4543480f98f131bf7421850bb32dbfdb" title="Remove all groups from the container.">removeAllGroups</a> </dd></dl>

</div>
</div>
<a id="af3eaf2bdab65f58c225b7aecd4879f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3eaf2bdab65f58c225b7aecd4879f84">&#9670;&nbsp;</a></span>removeIf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classime_1_1_object_container.html">ime::ObjectContainer</a>&lt; T &gt;::removeIf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object_container.html#aab7510136cf7c452265d68aeac0f2615">Predicate</a> &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditionally remove objects from the container. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>A function which returns true if the object should be removed or false if it should not be removed from the container</td></tr>
  </table>
  </dd>
</dl>
<p>Note that this function will remove all objects for which the predicate return true</p>
<dl class="section warning"><dt>Warning</dt><dd>This function will invalidate any pointer(s) to the object once it is removed from the container </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_drawable_container_8h_source.html">DrawableContainer.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassime_1_1_rectangle_shape_html"><div class="ttname"><a href="classime_1_1_rectangle_shape.html">ime::RectangleShape</a></div><div class="ttdoc">A 2D shape having four sides and four corners (90 degree angles)</div><div class="ttdef"><b>Definition:</b> <a href="_rectangle_shape_8h_source.html#l00036">RectangleShape.h:36</a></div></div>
        </div>
        <div id="footer-container">
            <div id="footer">
                IME is licensed under the terms and conditions of the <a href="https://github.com/KwenaMashamaite/IME/blob/master/LICENSE">MIT license</a>.<br>
                Copyright &copy; 2020-2021 Kwena Mashamaite
            </div>
        </div>
    </body>
</html>
