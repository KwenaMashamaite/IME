<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>IME - Infinite Motion Engine</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="ime">Documentation of IME 2.0.0</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.20 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceime.html">ime</a></li><li class="navelem"><a class="el" href="classime_1_1_target_grid_mover.html">TargetGridMover</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classime_1_1_target_grid_mover-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ime::TargetGridMover Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for moving a game object to a specific position in the grid.  
 <a href="classime_1_1_target_grid_mover.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_target_grid_mover_8h_source.html">TargetGridMover.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ime::TargetGridMover:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classime_1_1_target_grid_mover.png" usemap="#ime::TargetGridMover_map" alt=""/>
  <map id="ime::TargetGridMover_map" name="ime::TargetGridMover_map">
<area href="classime_1_1_grid_mover.html" title="Class for performing grid based movement on an entity in a grid." alt="ime::GridMover" shape="rect" coords="0,56,134,80"/>
<area href="classime_1_1_object.html" title="An abstract top-level base class for IME objects." alt="ime::Object" shape="rect" coords="0,0,134,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb2fb126bcdd0f8c089aa71026ef355e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#acb2fb126bcdd0f8c089aa71026ef355e">Ptr</a> = std::unique_ptr&lt; <a class="el" href="classime_1_1_target_grid_mover.html">TargetGridMover</a> &gt;</td></tr>
<tr class="memdesc:acb2fb126bcdd0f8c089aa71026ef355e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique grid mover pointer.  <a href="classime_1_1_target_grid_mover.html#acb2fb126bcdd0f8c089aa71026ef355e">More...</a><br /></td></tr>
<tr class="separator:acb2fb126bcdd0f8c089aa71026ef355e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b612eb1a30ee0d7012a891a805e93a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a> { <br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aae1ba155a9f2e8c3be94020eef32a0301">Type::Manual</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aa64663f4646781c9c0110838b905daa23">Type::Random</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aac41a31890959544c6523af684561abe5">Type::Target</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aaa55529813aef6ca28b9d22ee0442e02b">Type::KeyboardControlled</a>, 
<br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93aa90589c47f06eb971d548591f23c285af">Type::Custom</a>
<br />
 }</td></tr>
<tr class="memdesc:a07b612eb1a30ee0d7012a891a805e93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of grid movers.  <a href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">More...</a><br /></td></tr>
<tr class="separator:a07b612eb1a30ee0d7012a891a805e93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> { <br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca6adf97f83acf6453d4a6a4b1070f3754">MoveRestriction::None</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fcab1c94ca2fbc3e78fc30069c8d0f01680">MoveRestriction::All</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca06ce2a25e5d12c166a36f654dbea6012">MoveRestriction::Vertical</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fcac1b5fa03ecdb95d4a45dd1c40b02527f">MoveRestriction::Horizontal</a>, 
<br />
&#160;&#160;<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca9ac677ee4eec25d9e59707a661d2c5e1">MoveRestriction::Diagonal</a>, 
<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fca3e85a6323568ffe699745b4eef821495">MoveRestriction::NonDiagonal</a>
<br />
 }</td></tr>
<tr class="memdesc:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restricts the movement of the target along axes.  <a href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">More...</a><br /></td></tr>
<tr class="separator:a62c372e0dbb8e5a0be9b8fa5fd9724fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f37f1575bd7c48450ba1a75a68e606"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ae6f37f1575bd7c48450ba1a75a68e606">CollisionCallback</a> = <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_game_object.html">GameObject</a> *, <a class="el" href="classime_1_1_game_object.html">GameObject</a> * &gt;</td></tr>
<tr class="memdesc:ae6f37f1575bd7c48450ba1a75a68e606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when collision takes place.  <a href="classime_1_1_grid_mover.html#ae6f37f1575bd7c48450ba1a75a68e606">More...</a><br /></td></tr>
<tr class="separator:ae6f37f1575bd7c48450ba1a75a68e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a716f0fb9d219f045a1fa9dc48c33c4a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a716f0fb9d219f045a1fa9dc48c33c4a5">TargetGridMover</a> (<a class="el" href="classime_1_1_tile_map.html">TileMap</a> &amp;tileMap, <a class="el" href="classime_1_1_game_object.html">GameObject</a> *target=nullptr)</td></tr>
<tr class="memdesc:a716f0fb9d219f045a1fa9dc48c33c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a random grid mover object.  <a href="classime_1_1_target_grid_mover.html#a716f0fb9d219f045a1fa9dc48c33c4a5">More...</a><br /></td></tr>
<tr class="separator:a716f0fb9d219f045a1fa9dc48c33c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52bbb5eb1a4052656dda478b89e4c6e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#ad52bbb5eb1a4052656dda478b89e4c6e">getClassName</a> () const override</td></tr>
<tr class="memdesc:ad52bbb5eb1a4052656dda478b89e4c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this class.  <a href="classime_1_1_target_grid_mover.html#ad52bbb5eb1a4052656dda478b89e4c6e">More...</a><br /></td></tr>
<tr class="separator:ad52bbb5eb1a4052656dda478b89e4c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48987d1e2fe8c55b07e45726d3c92e54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a48987d1e2fe8c55b07e45726d3c92e54">setPathFinder</a> (std::unique_ptr&lt; <a class="el" href="classime_1_1_i_path_finder_strategy.html">IPathFinderStrategy</a> &gt; pathFinder)</td></tr>
<tr class="memdesc:a48987d1e2fe8c55b07e45726d3c92e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the path finder.  <a href="classime_1_1_target_grid_mover.html#a48987d1e2fe8c55b07e45726d3c92e54">More...</a><br /></td></tr>
<tr class="separator:a48987d1e2fe8c55b07e45726d3c92e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ff1a4b05ebb6dd5e82975e3620772"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#ae33ff1a4b05ebb6dd5e82975e3620772">setDestination</a> (<a class="el" href="structime_1_1_index.html">Index</a> index)</td></tr>
<tr class="memdesc:ae33ff1a4b05ebb6dd5e82975e3620772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index of the tile the target should go to.  <a href="classime_1_1_target_grid_mover.html#ae33ff1a4b05ebb6dd5e82975e3620772">More...</a><br /></td></tr>
<tr class="separator:ae33ff1a4b05ebb6dd5e82975e3620772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5c796207d09f91712324e097d28039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a3a5c796207d09f91712324e097d28039">setDestination</a> (<a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> position)</td></tr>
<tr class="memdesc:a3a5c796207d09f91712324e097d28039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the position the target should go to.  <a href="classime_1_1_target_grid_mover.html#a3a5c796207d09f91712324e097d28039">More...</a><br /></td></tr>
<tr class="separator:a3a5c796207d09f91712324e097d28039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb16e8b4ed5532ba1237141d70f742d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structime_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a2cb16e8b4ed5532ba1237141d70f742d">getDestination</a> () const</td></tr>
<tr class="memdesc:a2cb16e8b4ed5532ba1237141d70f742d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the destination position of the target.  <a href="classime_1_1_target_grid_mover.html#a2cb16e8b4ed5532ba1237141d70f742d">More...</a><br /></td></tr>
<tr class="separator:a2cb16e8b4ed5532ba1237141d70f742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe799b95f47e9bb34e7436f7817d4722"><td class="memItemLeft" align="right" valign="top">const std::stack&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#afe799b95f47e9bb34e7436f7817d4722">getPath</a> () const</td></tr>
<tr class="memdesc:afe799b95f47e9bb34e7436f7817d4722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the path of the target.  <a href="classime_1_1_target_grid_mover.html#afe799b95f47e9bb34e7436f7817d4722">More...</a><br /></td></tr>
<tr class="separator:afe799b95f47e9bb34e7436f7817d4722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade50a634406c18021f994283702a0907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#ade50a634406c18021f994283702a0907">clearPath</a> ()</td></tr>
<tr class="memdesc:ade50a634406c18021f994283702a0907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the current path of the target.  <a href="classime_1_1_target_grid_mover.html#ade50a634406c18021f994283702a0907">More...</a><br /></td></tr>
<tr class="separator:ade50a634406c18021f994283702a0907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed187e398e094fab78991487783d2326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#aed187e398e094fab78991487783d2326">isDestinationReachable</a> (<a class="el" href="structime_1_1_index.html">Index</a> index)</td></tr>
<tr class="memdesc:aed187e398e094fab78991487783d2326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether or not a destination is reachable.  <a href="classime_1_1_target_grid_mover.html#aed187e398e094fab78991487783d2326">More...</a><br /></td></tr>
<tr class="separator:aed187e398e094fab78991487783d2326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9d65dd47d96148be35af6e615b2cda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#acf9d65dd47d96148be35af6e615b2cda">startMovement</a> ()</td></tr>
<tr class="memdesc:acf9d65dd47d96148be35af6e615b2cda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start moving the target to its destination tile.  <a href="classime_1_1_target_grid_mover.html#acf9d65dd47d96148be35af6e615b2cda">More...</a><br /></td></tr>
<tr class="separator:acf9d65dd47d96148be35af6e615b2cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b339c8b28d83ab65247aab40570d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a09b339c8b28d83ab65247aab40570d06">stopMovement</a> ()</td></tr>
<tr class="memdesc:a09b339c8b28d83ab65247aab40570d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the targets movement.  <a href="classime_1_1_target_grid_mover.html#a09b339c8b28d83ab65247aab40570d06">More...</a><br /></td></tr>
<tr class="separator:a09b339c8b28d83ab65247aab40570d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cabfa262b6cc45d9ede24ed503d835"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a12cabfa262b6cc45d9ede24ed503d835">setAdaptiveMoveEnable</a> (bool enable)</td></tr>
<tr class="memdesc:a12cabfa262b6cc45d9ede24ed503d835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable adaptive movement.  <a href="classime_1_1_target_grid_mover.html#a12cabfa262b6cc45d9ede24ed503d835">More...</a><br /></td></tr>
<tr class="separator:a12cabfa262b6cc45d9ede24ed503d835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a11da222fcd5ea60a3588adc194643"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#ac1a11da222fcd5ea60a3588adc194643">isAdaptiveMoveEnabled</a> () const</td></tr>
<tr class="memdesc:ac1a11da222fcd5ea60a3588adc194643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if adaptive movement is enabled or not.  <a href="classime_1_1_target_grid_mover.html#ac1a11da222fcd5ea60a3588adc194643">More...</a><br /></td></tr>
<tr class="separator:ac1a11da222fcd5ea60a3588adc194643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462a6e612366d8baf7e15b83cbc71755"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a462a6e612366d8baf7e15b83cbc71755">onDestinationReached</a> (<a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; callback)</td></tr>
<tr class="memdesc:a462a6e612366d8baf7e15b83cbc71755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a destination reached event.  <a href="classime_1_1_target_grid_mover.html#a462a6e612366d8baf7e15b83cbc71755">More...</a><br /></td></tr>
<tr class="separator:a462a6e612366d8baf7e15b83cbc71755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a77cd910f82fa19210873cc2f43f152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a8a77cd910f82fa19210873cc2f43f152">setPathViewEnable</a> (bool showPath)</td></tr>
<tr class="memdesc:a8a77cd910f82fa19210873cc2f43f152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not the targets path should be shown or not.  <a href="classime_1_1_target_grid_mover.html#a8a77cd910f82fa19210873cc2f43f152">More...</a><br /></td></tr>
<tr class="separator:a8a77cd910f82fa19210873cc2f43f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739c29a8ac4ad6a2ee9012138be9281f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#a739c29a8ac4ad6a2ee9012138be9281f">isPathViewEnabled</a> () const</td></tr>
<tr class="memdesc:a739c29a8ac4ad6a2ee9012138be9281f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the targets path is shown or not.  <a href="classime_1_1_target_grid_mover.html#a739c29a8ac4ad6a2ee9012138be9281f">More...</a><br /></td></tr>
<tr class="separator:a739c29a8ac4ad6a2ee9012138be9281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca0e95b06bf7bd720257f2d60155495"><td class="memItemLeft" align="right" valign="top"><a id="a8ca0e95b06bf7bd720257f2d60155495"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>renderPath</b> (priv::Window &amp;window) const</td></tr>
<tr class="separator:a8ca0e95b06bf7bd720257f2d60155495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ab15420ad59e91c96d948e10f9e61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_target_grid_mover.html#af46ab15420ad59e91c96d948e10f9e61">~TargetGridMover</a> () override</td></tr>
<tr class="memdesc:af46ab15420ad59e91c96d948e10f9e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classime_1_1_target_grid_mover.html#af46ab15420ad59e91c96d948e10f9e61">More...</a><br /></td></tr>
<tr class="separator:af46ab15420ad59e91c96d948e10f9e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a8e3a0ca52ae74832ef1525671ba1b49c">getClassType</a> () const override</td></tr>
<tr class="memdesc:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this class.  <a href="classime_1_1_grid_mover.html#a8e3a0ca52ae74832ef1525671ba1b49c">More...</a><br /></td></tr>
<tr class="separator:a8e3a0ca52ae74832ef1525671ba1b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949fd379a9c58cb2401a7b446bc410a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a949fd379a9c58cb2401a7b446bc410a7">requestDirectionChange</a> (const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;newDir)</td></tr>
<tr class="memdesc:a949fd379a9c58cb2401a7b446bc410a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the direction of the game object.  <a href="classime_1_1_grid_mover.html#a949fd379a9c58cb2401a7b446bc410a7">More...</a><br /></td></tr>
<tr class="separator:a949fd379a9c58cb2401a7b446bc410a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ab796c7ce3807533afd9d64bce8425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a39ab796c7ce3807533afd9d64bce8425">getDirection</a> () const</td></tr>
<tr class="memdesc:a39ab796c7ce3807533afd9d64bce8425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current direction of the game object.  <a href="classime_1_1_grid_mover.html#a39ab796c7ce3807533afd9d64bce8425">More...</a><br /></td></tr>
<tr class="separator:a39ab796c7ce3807533afd9d64bce8425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae038f99785bbdb2b08ac608734386d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ae038f99785bbdb2b08ac608734386d05">setTarget</a> (<a class="el" href="classime_1_1_game_object.html">GameObject</a> *target)</td></tr>
<tr class="memdesc:ae038f99785bbdb2b08ac608734386d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the controlled entity.  <a href="classime_1_1_grid_mover.html#ae038f99785bbdb2b08ac608734386d05">More...</a><br /></td></tr>
<tr class="separator:ae038f99785bbdb2b08ac608734386d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960cb3cc0c3f1460b0f9ba40d0ed7ccc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_game_object.html">GameObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a960cb3cc0c3f1460b0f9ba40d0ed7ccc">getTarget</a> () const</td></tr>
<tr class="memdesc:a960cb3cc0c3f1460b0f9ba40d0ed7ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the controlled entity.  <a href="classime_1_1_grid_mover.html#a960cb3cc0c3f1460b0f9ba40d0ed7ccc">More...</a><br /></td></tr>
<tr class="separator:a960cb3cc0c3f1460b0f9ba40d0ed7ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85c7ed906d77ea8509ef271707a2d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ad85c7ed906d77ea8509ef271707a2d2d">setMaxLinearSpeed</a> (<a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> speed)</td></tr>
<tr class="memdesc:ad85c7ed906d77ea8509ef271707a2d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum linear speed of the game object.  <a href="classime_1_1_grid_mover.html#ad85c7ed906d77ea8509ef271707a2d2d">More...</a><br /></td></tr>
<tr class="separator:ad85c7ed906d77ea8509ef271707a2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de5b44e43e58400997275218ec765c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a8de5b44e43e58400997275218ec765c9">getMaxLinearSpeed</a> () const</td></tr>
<tr class="memdesc:a8de5b44e43e58400997275218ec765c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum speed of the game object.  <a href="classime_1_1_grid_mover.html#a8de5b44e43e58400997275218ec765c9">More...</a><br /></td></tr>
<tr class="separator:a8de5b44e43e58400997275218ec765c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121bf39232196e459b0c0b619e963c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b">setMovementRestriction</a> (<a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> moveRestriction)</td></tr>
<tr class="memdesc:a121bf39232196e459b0c0b619e963c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restrict the movement of the game object to certain directions.  <a href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b">More...</a><br /></td></tr>
<tr class="separator:a121bf39232196e459b0c0b619e963c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a04e9f2ca7f76fd6c6278797ab46e6a65">getMovementRestriction</a> () const</td></tr>
<tr class="memdesc:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current movement restriction of the game object.  <a href="classime_1_1_grid_mover.html#a04e9f2ca7f76fd6c6278797ab46e6a65">More...</a><br /></td></tr>
<tr class="separator:a04e9f2ca7f76fd6c6278797ab46e6a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a264750eeefd2cacf760ad9d785d3a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7">setMovementFreeze</a> (bool freeze)</td></tr>
<tr class="memdesc:a2a264750eeefd2cacf760ad9d785d3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Freeze or unfreeze the targets movement.  <a href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7">More...</a><br /></td></tr>
<tr class="separator:a2a264750eeefd2cacf760ad9d785d3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c162f7555b076e7a490baca60edcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a7f7c162f7555b076e7a490baca60edcd">isMovementFrozen</a> () const</td></tr>
<tr class="memdesc:a7f7c162f7555b076e7a490baca60edcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the targets movement is frozen or not.  <a href="classime_1_1_grid_mover.html#a7f7c162f7555b076e7a490baca60edcd">More...</a><br /></td></tr>
<tr class="separator:a7f7c162f7555b076e7a490baca60edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a2d8d4f8b4e4e73be5a3e4581874fa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structime_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ab1a2d8d4f8b4e4e73be5a3e4581874fa">getTargetTileIndex</a> () const</td></tr>
<tr class="memdesc:ab1a2d8d4f8b4e4e73be5a3e4581874fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the adjacent tile the target is trying to reach.  <a href="classime_1_1_grid_mover.html#ab1a2d8d4f8b4e4e73be5a3e4581874fa">More...</a><br /></td></tr>
<tr class="separator:ab1a2d8d4f8b4e4e73be5a3e4581874fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af8722af658036b2f6b7b40fe5bdbf1e4">getType</a> () const</td></tr>
<tr class="memdesc:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type of the grid mover.  <a href="classime_1_1_grid_mover.html#af8722af658036b2f6b7b40fe5bdbf1e4">More...</a><br /></td></tr>
<tr class="separator:af8722af658036b2f6b7b40fe5bdbf1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9219f5e3efe58eeeb17b05043d3f5ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classime_1_1_tile_map.html">TileMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a9219f5e3efe58eeeb17b05043d3f5ae6">getGrid</a> ()</td></tr>
<tr class="memdesc:a9219f5e3efe58eeeb17b05043d3f5ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the grid in which the target is moved in.  <a href="classime_1_1_grid_mover.html#a9219f5e3efe58eeeb17b05043d3f5ae6">More...</a><br /></td></tr>
<tr class="separator:a9219f5e3efe58eeeb17b05043d3f5ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a02f5fa61e79eb82d380ddacfc29dc"><td class="memItemLeft" align="right" valign="top"><a id="ae1a02f5fa61e79eb82d380ddacfc29dc"></a>
const <a class="el" href="classime_1_1_tile_map.html">TileMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getGrid</b> () const</td></tr>
<tr class="separator:ae1a02f5fa61e79eb82d380ddacfc29dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f703bf9dfc0c91c76716dac3ded84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af2f703bf9dfc0c91c76716dac3ded84a">isTargetMoving</a> () const</td></tr>
<tr class="memdesc:af2f703bf9dfc0c91c76716dac3ded84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if target is moving or not.  <a href="classime_1_1_grid_mover.html#af2f703bf9dfc0c91c76716dac3ded84a">More...</a><br /></td></tr>
<tr class="separator:af2f703bf9dfc0c91c76716dac3ded84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1861b96d89d9bc4539eda2cdacd356b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a1861b96d89d9bc4539eda2cdacd356b8">teleportTargetToDestination</a> ()</td></tr>
<tr class="memdesc:a1861b96d89d9bc4539eda2cdacd356b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force the target to reach it's destination.  <a href="classime_1_1_grid_mover.html#a1861b96d89d9bc4539eda2cdacd356b8">More...</a><br /></td></tr>
<tr class="separator:a1861b96d89d9bc4539eda2cdacd356b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af257d181ebc92037dd528ca2620430bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#af257d181ebc92037dd528ca2620430bd">onAdjacentMoveBegin</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:af257d181ebc92037dd528ca2620430bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a move begin event.  <a href="classime_1_1_grid_mover.html#af257d181ebc92037dd528ca2620430bd">More...</a><br /></td></tr>
<tr class="separator:af257d181ebc92037dd528ca2620430bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4e4123918ce592d35c746d54c9afd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#acc4e4123918ce592d35c746d54c9afd4">onAdjacentMoveEnd</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:acc4e4123918ce592d35c746d54c9afd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an adjacent tile reached event.  <a href="classime_1_1_grid_mover.html#acc4e4123918ce592d35c746d54c9afd4">More...</a><br /></td></tr>
<tr class="separator:acc4e4123918ce592d35c746d54c9afd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d383d73f62c2278f2c5fcd2c09df7ef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a0d383d73f62c2278f2c5fcd2c09df7ef">onGridBorderCollision</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback)</td></tr>
<tr class="memdesc:a0d383d73f62c2278f2c5fcd2c09df7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a tilemap border collision event.  <a href="classime_1_1_grid_mover.html#a0d383d73f62c2278f2c5fcd2c09df7ef">More...</a><br /></td></tr>
<tr class="separator:a0d383d73f62c2278f2c5fcd2c09df7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73972371b0e75a8fdccb788461d07464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a73972371b0e75a8fdccb788461d07464">onTileCollision</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:a73972371b0e75a8fdccb788461d07464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a tile collision event.  <a href="classime_1_1_grid_mover.html#a73972371b0e75a8fdccb788461d07464">More...</a><br /></td></tr>
<tr class="separator:a73972371b0e75a8fdccb788461d07464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2a771121d85e730cd03dc43f181a84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#a4e2a771121d85e730cd03dc43f181a84">onGameObjectCollision</a> (const <a class="el" href="classime_1_1_grid_mover.html#ae6f37f1575bd7c48450ba1a75a68e606">CollisionCallback</a> &amp;callback)</td></tr>
<tr class="memdesc:a4e2a771121d85e730cd03dc43f181a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a game object collision.  <a href="classime_1_1_grid_mover.html#a4e2a771121d85e730cd03dc43f181a84">More...</a><br /></td></tr>
<tr class="separator:a4e2a771121d85e730cd03dc43f181a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fb43eb9a13ec364398d86b77e0a23a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a">unsubscribe</a> (int handlerId)</td></tr>
<tr class="memdesc:ac2fb43eb9a13ec364398d86b77e0a23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an event listener from the grid movers event list.  <a href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a">More...</a><br /></td></tr>
<tr class="separator:ac2fb43eb9a13ec364398d86b77e0a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d24db78b5837e3cbacf4ddcea2bffd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a80d24db78b5837e3cbacf4ddcea2bffd">unsubscribe</a> (const std::string &amp;event, int id)</td></tr>
<tr class="memdesc:a80d24db78b5837e3cbacf4ddcea2bffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an event listener from an event.  <a href="classime_1_1_object.html#a80d24db78b5837e3cbacf4ddcea2bffd">More...</a><br /></td></tr>
<tr class="separator:a80d24db78b5837e3cbacf4ddcea2bffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade350b65cfb3791254d942550882b895"><td class="memItemLeft" align="right" valign="top"><a id="ade350b65cfb3791254d942550882b895"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetTargetTile</b> ()</td></tr>
<tr class="separator:ade350b65cfb3791254d942550882b895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a2db0ee1eb9cc166a45a3659a0d0c4"><td class="memItemLeft" align="right" valign="top"><a id="a11a2db0ee1eb9cc166a45a3659a0d0c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>onTargetTileReset</b> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;callback)</td></tr>
<tr class="separator:a11a2db0ee1eb9cc166a45a3659a0d0c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a044636465db4810ae547e248049bc"><td class="memItemLeft" align="right" valign="top"><a id="a79a044636465db4810ae547e248049bc"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> (<a class="el" href="classime_1_1_time.html">Time</a> deltaTime)</td></tr>
<tr class="separator:a79a044636465db4810ae547e248049bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">setTag</a> (const std::string &amp;tag)</td></tr>
<tr class="memdesc:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the object an alias.  <a href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">More...</a><br /></td></tr>
<tr class="separator:aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ab83221ea2cf2002ee4657cc8b3d39c87">getTag</a> () const</td></tr>
<tr class="memdesc:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tag assigned to the object.  <a href="classime_1_1_object.html#ab83221ea2cf2002ee4657cc8b3d39c87">More...</a><br /></td></tr>
<tr class="separator:ab83221ea2cf2002ee4657cc8b3d39c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e9c8f45f13c68e129775bc058231af"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af">getObjectId</a> () const</td></tr>
<tr class="memdesc:ac2e9c8f45f13c68e129775bc058231af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the unique id of the object.  <a href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af">More...</a><br /></td></tr>
<tr class="separator:ac2e9c8f45f13c68e129775bc058231af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc3828b0ab7ab19c2d4140e46a79ab6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a8cc3828b0ab7ab19c2d4140e46a79ab6">onPropertyChange</a> (const std::string &amp;property, const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:a8cc3828b0ab7ab19c2d4140e46a79ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to a specific property change event.  <a href="classime_1_1_object.html#a8cc3828b0ab7ab19c2d4140e46a79ab6">More...</a><br /></td></tr>
<tr class="separator:a8cc3828b0ab7ab19c2d4140e46a79ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7186aa3a456280290c241104a63dd1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ada7186aa3a456280290c241104a63dd1">onPropertyChange</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;callback)</td></tr>
<tr class="memdesc:ada7186aa3a456280290c241104a63dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to any property change event.  <a href="classime_1_1_object.html#ada7186aa3a456280290c241104a63dd1">More...</a><br /></td></tr>
<tr class="separator:ada7186aa3a456280290c241104a63dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e54a035475da4d91215334638db4ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a14e54a035475da4d91215334638db4ed">onEvent</a> (const std::string &amp;event, const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback)</td></tr>
<tr class="memdesc:a14e54a035475da4d91215334638db4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener to an action event.  <a href="classime_1_1_object.html#a14e54a035475da4d91215334638db4ed">More...</a><br /></td></tr>
<tr class="separator:a14e54a035475da4d91215334638db4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cca84e762939e48b6949d0aa87e571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a13cca84e762939e48b6949d0aa87e571">onDestruction</a> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback)</td></tr>
<tr class="memdesc:a13cca84e762939e48b6949d0aa87e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a destruction listener.  <a href="classime_1_1_object.html#a13cca84e762939e48b6949d0aa87e571">More...</a><br /></td></tr>
<tr class="separator:a13cca84e762939e48b6949d0aa87e571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec2a30421bb88f1ab6ed598de3bb3bb"><td class="memItemLeft" align="right" valign="top"><a id="a1ec2a30421bb88f1ab6ed598de3bb3bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>onDestruction</b> (const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;callback) const</td></tr>
<tr class="separator:a1ec2a30421bb88f1ab6ed598de3bb3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac34ba77e7e078b1cca2a5210cdb39d7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ac34ba77e7e078b1cca2a5210cdb39d7a">removeDestructionListener</a> (int id)</td></tr>
<tr class="memdesc:ac34ba77e7e078b1cca2a5210cdb39d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a destruction listener form the object.  <a href="classime_1_1_object.html#ac34ba77e7e078b1cca2a5210cdb39d7a">More...</a><br /></td></tr>
<tr class="separator:ac34ba77e7e078b1cca2a5210cdb39d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c9e842a4081f105b90e3c2374e36ac"><td class="memItemLeft" align="right" valign="top"><a id="ac0c9e842a4081f105b90e3c2374e36ac"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeDestructionListener</b> (int id) const</td></tr>
<tr class="separator:ac0c9e842a4081f105b90e3c2374e36ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12faee572285c98d73ad1dd4cac88c04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a12faee572285c98d73ad1dd4cac88c04">operator==</a> (const <a class="el" href="classime_1_1_object.html">Object</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a12faee572285c98d73ad1dd4cac88c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two objects are the same object or not.  <a href="classime_1_1_object.html#a12faee572285c98d73ad1dd4cac88c04">More...</a><br /></td></tr>
<tr class="separator:a12faee572285c98d73ad1dd4cac88c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebaae148bc8076d5c7c605b3e0cfb05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a4ebaae148bc8076d5c7c605b3e0cfb05">operator!=</a> (const <a class="el" href="classime_1_1_object.html">Object</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a4ebaae148bc8076d5c7c605b3e0cfb05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two objects are Not the same object.  <a href="classime_1_1_object.html#a4ebaae148bc8076d5c7c605b3e0cfb05">More...</a><br /></td></tr>
<tr class="separator:a4ebaae148bc8076d5c7c605b3e0cfb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f">emitChange</a> (const <a class="el" href="classime_1_1_property.html">Property</a> &amp;property)</td></tr>
<tr class="memdesc:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a property change event.  <a href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f">More...</a><br /></td></tr>
<tr class="separator:a18e26cf15b23c3f2a349ace7ec17cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76e7dca0401363b65fcee10d315e043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classime_1_1_object.html#ab76e7dca0401363b65fcee10d315e043">emit</a> (const std::string &amp;event)</td></tr>
<tr class="memdesc:ab76e7dca0401363b65fcee10d315e043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch an action event.  <a href="classime_1_1_object.html#ab76e7dca0401363b65fcee10d315e043">More...</a><br /></td></tr>
<tr class="separator:ab76e7dca0401363b65fcee10d315e043"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for moving a game object to a specific position in the grid. </p>

<p class="definition">Definition at line <a class="el" href="_target_grid_mover_8h_source.html#l00041">41</a> of file <a class="el" href="_target_grid_mover_8h_source.html">TargetGridMover.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae6f37f1575bd7c48450ba1a75a68e606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f37f1575bd7c48450ba1a75a68e606">&#9670;&nbsp;</a></span>CollisionCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_grid_mover.html#ae6f37f1575bd7c48450ba1a75a68e606">ime::GridMover::CollisionCallback</a> =  <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;<a class="el" href="classime_1_1_game_object.html">GameObject</a>*, <a class="el" href="classime_1_1_game_object.html">GameObject</a>*&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when collision takes place. </p>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00062">62</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<a id="acb2fb126bcdd0f8c089aa71026ef355e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2fb126bcdd0f8c089aa71026ef355e">&#9670;&nbsp;</a></span>Ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classime_1_1_target_grid_mover.html#acb2fb126bcdd0f8c089aa71026ef355e">ime::TargetGridMover::Ptr</a> =  std::unique_ptr&lt;<a class="el" href="classime_1_1_target_grid_mover.html">TargetGridMover</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique grid mover pointer. </p>

<p class="definition">Definition at line <a class="el" href="_target_grid_mover_8h_source.html#l00043">43</a> of file <a class="el" href="_target_grid_mover_8h_source.html">TargetGridMover.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a62c372e0dbb8e5a0be9b8fa5fd9724fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c372e0dbb8e5a0be9b8fa5fd9724fc">&#9670;&nbsp;</a></span>MoveRestriction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">ime::GridMover::MoveRestriction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restricts the movement of the target along axes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Target can move in all in all 8 directions (W, NW, N, NE, E, SE, S, SW) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fcab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Target cannot move in any direction. </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca06ce2a25e5d12c166a36f654dbea6012"></a>Vertical&#160;</td><td class="fielddoc"><p>Target can only move vertically (N or S) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fcac1b5fa03ecdb95d4a45dd1c40b02527f"></a>Horizontal&#160;</td><td class="fielddoc"><p>Target can only move horizontally (W or E) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca9ac677ee4eec25d9e59707a661d2c5e1"></a>Diagonal&#160;</td><td class="fielddoc"><p>Target can only move diagonally (NW, NE, SE, SW) </p>
</td></tr>
<tr><td class="fieldname"><a id="a62c372e0dbb8e5a0be9b8fa5fd9724fca3e85a6323568ffe699745b4eef821495"></a>NonDiagonal&#160;</td><td class="fielddoc"><p>Target can only move non-diagonally (W, N, E, S) </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00078">78</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<a id="a07b612eb1a30ee0d7012a891a805e93a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b612eb1a30ee0d7012a891a805e93a">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">ime::GridMover::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Types of grid movers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aae1ba155a9f2e8c3be94020eef32a0301"></a>Manual&#160;</td><td class="fielddoc"><p>Manually triggered grid mover. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aa64663f4646781c9c0110838b905daa23"></a>Random&#160;</td><td class="fielddoc"><p>Moves a game object randomly in the grid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aac41a31890959544c6523af684561abe5"></a>Target&#160;</td><td class="fielddoc"><p>Moves a game object to a specific tile within the grid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aaa55529813aef6ca28b9d22ee0442e02b"></a>KeyboardControlled&#160;</td><td class="fielddoc"><p>Moves a game object within the grid using the keyboard as a trigger. </p>
</td></tr>
<tr><td class="fieldname"><a id="a07b612eb1a30ee0d7012a891a805e93aa90589c47f06eb971d548591f23c285af"></a>Custom&#160;</td><td class="fielddoc"><p>For classes that extend the grid mover outside of IME. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="_grid_mover_8h_source.html#l00067">67</a> of file <a class="el" href="_grid_mover_8h_source.html">GridMover.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a716f0fb9d219f045a1fa9dc48c33c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716f0fb9d219f045a1fa9dc48c33c4a5">&#9670;&nbsp;</a></span>TargetGridMover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::TargetGridMover::TargetGridMover </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_tile_map.html">TileMap</a> &amp;&#160;</td>
          <td class="paramname"><em>tileMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classime_1_1_game_object.html">GameObject</a> *&#160;</td>
          <td class="paramname"><em>target</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a random grid mover object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tileMap</td><td>Grid to move target in </td></tr>
    <tr><td class="paramname">target</td><td><a class="el" href="classime_1_1_game_object.html" title="Abstract base class for game objects (players, enemies etc...)">GameObject</a> to be moved in the grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The tilemap must be loaded before constructing this grid mover </dd></dl>

</div>
</div>
<a id="af46ab15420ad59e91c96d948e10f9e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ab15420ad59e91c96d948e10f9e61">&#9670;&nbsp;</a></span>~TargetGridMover()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ime::TargetGridMover::~TargetGridMover </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade50a634406c18021f994283702a0907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade50a634406c18021f994283702a0907">&#9670;&nbsp;</a></span>clearPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::clearPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the current path of the target. </p>
<p>If the target is currently en route on this path, it will stop when it gets to its currently targeted adjacent tile. In addition, if the targets movement was stopped while he was moving to an adjacent tile and is resumed after the path is cleared the target will resume the move to an adjacent tile and stop thereafter </p>

</div>
</div>
<a id="ab76e7dca0401363b65fcee10d315e043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76e7dca0401363b65fcee10d315e043">&#9670;&nbsp;</a></span>emit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::emit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch an action event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The name of the event to be dispatched</td></tr>
  </table>
  </dd>
</dl>
<p>This function will invoke all event listeners of the specified event. The function should be used for events that represent an action, rather than those that represent a property change (Use <a class="el" href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f" title="Dispatch a property change event.">emitChange()</a> for that)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#a18e26cf15b23c3f2a349ace7ec17cb2f" title="Dispatch a property change event.">emitChange</a> </dd></dl>

</div>
</div>
<a id="a18e26cf15b23c3f2a349ace7ec17cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e26cf15b23c3f2a349ace7ec17cb2f">&#9670;&nbsp;</a></span>emitChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::emitChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_property.html">Property</a> &amp;&#160;</td>
          <td class="paramname"><em>property</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch a property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The property that changed</td></tr>
  </table>
  </dd>
</dl>
<p>This function will invoke all the event listeners of the specified property</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ab76e7dca0401363b65fcee10d315e043" title="Dispatch an action event.">emit</a> </dd></dl>

</div>
</div>
<a id="ad52bbb5eb1a4052656dda478b89e4c6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52bbb5eb1a4052656dda478b89e4c6e">&#9670;&nbsp;</a></span>getClassName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ime::TargetGridMover::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class </dd></dl>

<p>Reimplemented from <a class="el" href="classime_1_1_grid_mover.html#a3b1482324fd09f1d7b544372e6ef108d">ime::GridMover</a>.</p>

</div>
</div>
<a id="a8e3a0ca52ae74832ef1525671ba1b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3a0ca52ae74832ef1525671ba1b49c">&#9670;&nbsp;</a></span>getClassType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ime::GridMover::getClassType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this class. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of this class</dd></dl>
<p>Note that this function is only implemented by child classes of <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> which also serve as a base class for other classes</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#a8c3d545176c422a07532de6e2eb35f84" title="Get the name of the direct parent of an object instance.">Object::getClassType</a> and <a class="el" href="classime_1_1_object.html#a893e90e8498458bd9d43fe9041a22f02" title="Get the name of the objects concrete class.">Object::getClassName</a> </dd></dl>

<p>Reimplemented from <a class="el" href="classime_1_1_object.html#a8c3d545176c422a07532de6e2eb35f84">ime::Object</a>.</p>

</div>
</div>
<a id="a2cb16e8b4ed5532ba1237141d70f742d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb16e8b4ed5532ba1237141d70f742d">&#9670;&nbsp;</a></span>getDestination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structime_1_1_index.html">Index</a> ime::TargetGridMover::getDestination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the destination position of the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The position that the target must reach</dd></dl>
<p>This destination will be returned even if the target has reached it </p>

</div>
</div>
<a id="a39ab796c7ce3807533afd9d64bce8425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ab796c7ce3807533afd9d64bce8425">&#9670;&nbsp;</a></span>getDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> ime::GridMover::getDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current direction of the game object. </p>
<dl class="section return"><dt>Returns</dt><dd>The current direction of the game object </dd></dl>

</div>
</div>
<a id="a9219f5e3efe58eeeb17b05043d3f5ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9219f5e3efe58eeeb17b05043d3f5ae6">&#9670;&nbsp;</a></span>getGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_tile_map.html">TileMap</a>&amp; ime::GridMover::getGrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to the grid in which the target is moved in. </p>
<dl class="section return"><dt>Returns</dt><dd>The grid in which the target is being moved in </dd></dl>

</div>
</div>
<a id="a8de5b44e43e58400997275218ec765c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de5b44e43e58400997275218ec765c9">&#9670;&nbsp;</a></span>getMaxLinearSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a> ime::GridMover::getMaxLinearSpeed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum speed of the game object. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum speed of the game object </dd></dl>

</div>
</div>
<a id="a04e9f2ca7f76fd6c6278797ab46e6a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e9f2ca7f76fd6c6278797ab46e6a65">&#9670;&nbsp;</a></span>getMovementRestriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a> ime::GridMover::getMovementRestriction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current movement restriction of the game object. </p>
<dl class="section return"><dt>Returns</dt><dd>The current movement restriction </dd></dl>

</div>
</div>
<a id="ac2e9c8f45f13c68e129775bc058231af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e9c8f45f13c68e129775bc058231af">&#9670;&nbsp;</a></span>getObjectId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ime::Object::getObjectId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the unique id of the object. </p>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the object</dd></dl>
<p>Note that each instance of <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">ime::Object</a> has a unique id</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag</a> </dd></dl>

</div>
</div>
<a id="afe799b95f47e9bb34e7436f7817d4722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe799b95f47e9bb34e7436f7817d4722">&#9670;&nbsp;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::stack&lt;<a class="el" href="structime_1_1_index.html">Index</a>&gt;&amp; ime::TargetGridMover::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the path of the target. </p>
<dl class="section return"><dt>Returns</dt><dd>The path of the target </dd></dl>

</div>
</div>
<a id="ab83221ea2cf2002ee4657cc8b3d39c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83221ea2cf2002ee4657cc8b3d39c87">&#9670;&nbsp;</a></span>getTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; ime::Object::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the tag assigned to the object. </p>
<dl class="section return"><dt>Returns</dt><dd>The tag of the object</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag</a> </dd></dl>

</div>
</div>
<a id="a960cb3cc0c3f1460b0f9ba40d0ed7ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960cb3cc0c3f1460b0f9ba40d0ed7ccc">&#9670;&nbsp;</a></span>getTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_game_object.html">GameObject</a>* ime::GridMover::getTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access to the controlled entity. </p>
<dl class="section return"><dt>Returns</dt><dd>The controlled entity, or a nullptr if there is no entity to control </dd></dl>

</div>
</div>
<a id="ab1a2d8d4f8b4e4e73be5a3e4581874fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a2d8d4f8b4e4e73be5a3e4581874fa">&#9670;&nbsp;</a></span>getTargetTileIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structime_1_1_index.html">Index</a> ime::GridMover::getTargetTileIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the adjacent tile the target is trying to reach. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the adjacent tile the target is trying to reach</dd></dl>
<p>If the target it not moving towards any tiles, this function will return the index of the tile currently occupied by the target </p>

<p>Reimplemented in <a class="el" href="classime_1_1_random_grid_mover.html#adb5e6583164e745566bf9f864f26670d">ime::RandomGridMover</a>.</p>

</div>
</div>
<a id="af8722af658036b2f6b7b40fe5bdbf1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8722af658036b2f6b7b40fe5bdbf1e4">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classime_1_1_grid_mover.html#a07b612eb1a30ee0d7012a891a805e93a">Type</a> ime::GridMover::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the type of the grid mover. </p>
<dl class="section return"><dt>Returns</dt><dd>The type of the grid mover </dd></dl>

</div>
</div>
<a id="ac1a11da222fcd5ea60a3588adc194643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a11da222fcd5ea60a3588adc194643">&#9670;&nbsp;</a></span>isAdaptiveMoveEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::TargetGridMover::isAdaptiveMoveEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if adaptive movement is enabled or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if enabled, otherwise false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_target_grid_mover.html#a12cabfa262b6cc45d9ede24ed503d835" title="Enable or disable adaptive movement.">setAdaptiveMoveEnable</a> </dd></dl>

</div>
</div>
<a id="aed187e398e094fab78991487783d2326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed187e398e094fab78991487783d2326">&#9670;&nbsp;</a></span>isDestinationReachable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::TargetGridMover::isDestinationReachable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structime_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether or not a destination is reachable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Destination to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the destination is reachable from the targets current position otherwise false</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is expensive when the tilemap has a lot of accessible tiles because the path is regenerated every time the function is called to accommodate changes in position since the destination was set</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_target_grid_mover.html#ae33ff1a4b05ebb6dd5e82975e3620772" title="Set the index of the tile the target should go to.">setDestination</a> </dd></dl>

</div>
</div>
<a id="a7f7c162f7555b076e7a490baca60edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7c162f7555b076e7a490baca60edcd">&#9670;&nbsp;</a></span>isMovementFrozen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::isMovementFrozen </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the targets movement is frozen or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if movement is frozen otherwise false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7" title="Freeze or unfreeze the targets movement.">setMovementFreeze</a> </dd></dl>

</div>
</div>
<a id="a739c29a8ac4ad6a2ee9012138be9281f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739c29a8ac4ad6a2ee9012138be9281f">&#9670;&nbsp;</a></span>isPathViewEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::TargetGridMover::isPathViewEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the targets path is shown or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if path view is enabled, otherwise false</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_target_grid_mover.html#a8a77cd910f82fa19210873cc2f43f152" title="Set whether or not the targets path should be shown or not.">setPathViewEnable</a> </dd></dl>

</div>
</div>
<a id="af2f703bf9dfc0c91c76716dac3ded84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f703bf9dfc0c91c76716dac3ded84a">&#9670;&nbsp;</a></span>isTargetMoving()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::isTargetMoving </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if target is moving or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if target is moving otherwise false</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will return false if the target is not moving or there is no target set. Therefore, the existence of the target should be checked first for accurate results</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a960cb3cc0c3f1460b0f9ba40d0ed7ccc" title="Get access to the controlled entity.">getTarget</a> </dd></dl>

</div>
</div>
<a id="af257d181ebc92037dd528ca2620430bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af257d181ebc92037dd528ca2620430bd">&#9670;&nbsp;</a></span>onAdjacentMoveBegin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onAdjacentMoveBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a move begin event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when the game object starts moving </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners unique identification number</dd></dl>
<p>This event is emitted when the game object starts moving from its current tile to one of its adjacent tile. The callback is passed the index of the tile that the game object is currently moving to</p>
<dl class="section note"><dt>Note</dt><dd>When controlled by a grid mover, the game object will always move one tile at a time, regardless of how fast it's moving</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#acc4e4123918ce592d35c746d54c9afd4" title="Add an event listener to an adjacent tile reached event.">onAdjacentMoveEnd</a> </dd></dl>

</div>
</div>
<a id="acc4e4123918ce592d35c746d54c9afd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4e4123918ce592d35c746d54c9afd4">&#9670;&nbsp;</a></span>onAdjacentMoveEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onAdjacentMoveEnd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to an adjacent tile reached event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target reaches its target tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target moves from its current tile to any of its adjacent tiles.</p>
<dl class="section note"><dt>Note</dt><dd>When controlled by a grid mover, the target will always move one tile at a time, regardless of how fast the target is moving</dd></dl>
<p>The callback is passed the index of the tile the target moved to</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#af257d181ebc92037dd528ca2620430bd" title="Add an event listener to a move begin event.">onAdjacentMoveBegin</a> </dd></dl>

</div>
</div>
<a id="a462a6e612366d8baf7e15b83cbc71755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462a6e612366d8baf7e15b83cbc71755">&#9670;&nbsp;</a></span>onDestinationReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ime::TargetGridMover::onDestinationReached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener to a destination reached event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the target reaches its destination tile </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is fired when the target reaches the final target tile</p>
<p>The callback is passed the destination tile of the target after it reaches it</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#acc4e4123918ce592d35c746d54c9afd4" title="Add an event listener to an adjacent tile reached event.">onAdjacentMoveEnd</a> </dd></dl>

</div>
</div>
<a id="a13cca84e762939e48b6949d0aa87e571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cca84e762939e48b6949d0aa87e571">&#9670;&nbsp;</a></span>onDestruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onDestruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a destruction listener. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to be executed when the object is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the destruction listener</dd></dl>
<p>The destruction listener is called when the object reaches the end of its lifetime. Note that an object may have multiple destruction listeners registered to it</p>
<dl class="section warning"><dt>Warning</dt><dd>It's not advised to call virtual functions in the destruction callback as some parts of the object may have already been destroyed by the time the callback is invoked. In such an event, the behavior is undefined</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ac34ba77e7e078b1cca2a5210cdb39d7a" title="Remove a destruction listener form the object.">removeDestructionListener</a> </dd></dl>

</div>
</div>
<a id="a14e54a035475da4d91215334638db4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e54a035475da4d91215334638db4ed">&#9670;&nbsp;</a></span>onEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onEvent </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to an action event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The name of the event to add an an event listener to </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be executed when the event takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique identification number of the event listener</dd></dl>
<p>Unlike <a class="el" href="classime_1_1_object.html#a8cc3828b0ab7ab19c2d4140e46a79ab6" title="Add an event listener to a specific property change event.">onPropertyChange()</a>, this function registers event listeners to events that occur when something happens to the object, or when the object does something (action events). The name of the event or action is the name of the function:</p>
<div class="fragment"><div class="line"><span class="comment">// Add event listeners to the object</span></div>
<div class="line"><span class="keywordtype">object</span>.onEvent(<span class="stringliteral">&quot;attachRigidBody&quot;</span>, [] {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Rigid body attached to object &lt;&lt; std::endl;</span></div>
<div class="line"><span class="stringliteral">});</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">object.onEvent(&quot;</span>removeRigidBody<span class="stringliteral">&quot;, [] {</span></div>
<div class="line"><span class="stringliteral">    std::cout &lt;&lt; &quot;</span>Rigid body removed from <span class="keywordtype">object</span> &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Invokes event listener(s)</span></div>
<div class="line"><span class="keywordtype">object</span>.attachRigidBody(body);</div>
<div class="line"><span class="keywordtype">object</span>.removeRigidBody();</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#a8cc3828b0ab7ab19c2d4140e46a79ab6" title="Add an event listener to a specific property change event.">onPropertyChange</a> and <a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a" title="Remove an event listener from the grid movers event list.">unsubscribe</a> </dd></dl>

</div>
</div>
<a id="a4e2a771121d85e730cd03dc43f181a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2a771121d85e730cd03dc43f181a84">&#9670;&nbsp;</a></span>onGameObjectCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onGameObjectCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_grid_mover.html#ae6f37f1575bd7c48450ba1a75a68e606">CollisionCallback</a> &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a game object collision. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when the collision take place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners unique identifier</dd></dl>
<p>The callback is invoked when the target collides with another game object. On invocation, the callback it is passed the target and the game object it collided with respectively.</p>
<dl class="section note"><dt>Note</dt><dd>A grid mover registers a collision between two game objects only when they occupy the same tile. That is, a collision will not be raised when the two game objects start overlapping. For contact based collision detection use <a class="el" href="classime_1_1_rigid_body.html" title="A rigid body.">RigidBody</a> physics</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a" title="Remove an event listener from the grid movers event list.">unsubscribe</a> </dd></dl>

</div>
</div>
<a id="a0d383d73f62c2278f2c5fcd2c09df7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d383d73f62c2278f2c5fcd2c09df7ef">&#9670;&nbsp;</a></span>onGridBorderCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onGridBorderCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a tilemap border collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target tries to go beyond the bounds of the grid. By default the event is handled internally before it's emitted to the outside. The internal handler prevents the target from leaving the grid. That is, the target will occupy the same tile it occupied before the collision. This behaviour is not removable, however, it may be overridden since the internal handler is called first before alerting external handlers</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a" title="Remove an event listener from the grid movers event list.">unsubscribe</a> </dd></dl>

</div>
</div>
<a id="ada7186aa3a456280290c241104a63dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7186aa3a456280290c241104a63dd1">&#9670;&nbsp;</a></span>onPropertyChange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to any property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function to be executed when any property changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the event listener</dd></dl>
<p>When unsubscribing the any property change event handler, you must pass <em>"propertyChange"</em> as the name of the event</p>
<dl class="section see"><dt>See also</dt><dd>onPropertyChange(const std::string&amp;, const ime::Callback&lt;ime::Property&gt;&amp;) </dd></dl>

</div>
</div>
<a id="a8cc3828b0ab7ab19c2d4140e46a79ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc3828b0ab7ab19c2d4140e46a79ab6">&#9670;&nbsp;</a></span>onPropertyChange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::Object::onPropertyChange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>property</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="classime_1_1_property.html">Property</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a specific property change event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">property</td><td>The name of the property to add an event listener to </td></tr>
    <tr><td class="paramname">callback</td><td>The function to be executed when the property changes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unique id of the event listener</dd></dl>
<p>A property change event is triggered by any function that begins with <em>set</em>, where the the text after <em>set</em> is the name of the property. For example, the <em><a class="el" href="classime_1_1_object.html#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c" title="Assign the object an alias.">setTag()</a></em> function, modifies the <em>tag</em> property of the object, thus will generate a "tag" change event each time it is called</p>
<p>Note that multiple event listeners may be registered to the same property change event. In addition, when adding a property change event listener, the name of the property must be in lowercase.</p>
<div class="fragment"><div class="line"><span class="comment">// Prints the tag of the player object to the console everytime it changes</span></div>
<div class="line">player.onPropertyChange(<span class="stringliteral">&quot;tag&quot;</span>, [](<span class="keyword">const</span> Property&amp; property) {</div>
<div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;New tag: &quot;</span> &lt;&lt;  <span class="keyword">property</span>.getValue&lt;std::string&gt;() &lt;&lt; endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"><span class="comment">//Sets tag = &quot;player1&quot; and invokes event listener(s)</span></div>
<div class="line">player.setTag(<span class="stringliteral">&quot;player1&quot;</span>);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a" title="Remove an event listener from the grid movers event list.">unsubscribe</a> and onPropertyChange(const ime::Callback&lt;ime::Property&gt;&amp;) </dd></dl>

</div>
</div>
<a id="a73972371b0e75a8fdccb788461d07464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73972371b0e75a8fdccb788461d07464">&#9670;&nbsp;</a></span>onTileCollision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ime::GridMover::onTileCollision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a3f45d9e0b4d574a5f97fb0a538bf7a1f">Callback</a>&lt; <a class="el" href="structime_1_1_index.html">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event listener to a tile collision event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>Function to execute when the collision takes place </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The event listeners identification number</dd></dl>
<p>This event is emitted when the target collides with a solid tile in the grid (Solid tiles are always collidable). By default, the event is handled internally before its emitted to the outside. The internal handler prevents the target from occupying the solid tile by moving it back to its previous tile after the collision</p>
<p>The callback is passed the index of the tile the target collided with</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#ac2fb43eb9a13ec364398d86b77e0a23a" title="Remove an event listener from the grid movers event list.">unsubscribe</a> </dd></dl>

</div>
</div>
<a id="a4ebaae148bc8076d5c7c605b3e0cfb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ebaae148bc8076d5c7c605b3e0cfb05">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two objects are Not the same object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> to compare against this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>rhs</em> is NOT the same object as this object, otherwise false</dd></dl>
<p>Two objects are different from each other if they have different object id's</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af" title="Get the unique id of the object.">getObjectId</a> </dd></dl>

</div>
</div>
<a id="a12faee572285c98d73ad1dd4cac88c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12faee572285c98d73ad1dd4cac88c04">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classime_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two objects are the same object or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td><a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">Object</a> to compare against this object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>rhs</em> is the same object as this object, otherwise false</dd></dl>
<p>Two objects are the same object if they have the same object id. Recall that each <a class="el" href="classime_1_1_object.html" title="An abstract top-level base class for IME objects.">ime::Object</a> instance has a unique id</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af" title="Get the unique id of the object.">getObjectId</a> </dd></dl>

</div>
</div>
<a id="ac34ba77e7e078b1cca2a5210cdb39d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac34ba77e7e078b1cca2a5210cdb39d7a">&#9670;&nbsp;</a></span>removeDestructionListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::removeDestructionListener </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a destruction listener form the object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The unique id of the destruction listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the destruction listener was removed or false if the destruction listener with the given id does not exist</dd></dl>
<dl class="section see"><dt>See also</dt><dd>addDestructionListener </dd></dl>

</div>
</div>
<a id="a949fd379a9c58cb2401a7b446bc410a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949fd379a9c58cb2401a7b446bc410a7">&#9670;&nbsp;</a></span>requestDirectionChange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::requestDirectionChange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceime.html#a648c4f6bb8c6dbeceb789b1c9aa5f738">Direction</a> &amp;&#160;</td>
          <td class="paramname"><em>newDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the direction of the game object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newDir</td><td>The new direction of the game object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the direction was changed or false if the game object is in motion or the grid mover is not in control of any game object</dd></dl>
<p>Note that the direction of the game object cannot be changed while it is moving to another tile. This function only works with predefined directions. In addition to returning <b>true</b> for successful direction change, the function will emit a "direction" property change event. Usually property change events are only emitted by setters (functions that begin with a "set" prefix)</p>
<div class="fragment"><div class="line">gridMover.onPropertyChange(<span class="stringliteral">&quot;direction&quot;</span>, [](<span class="keyword">const</span> <a class="code" href="classime_1_1_property.html">ime::Property</a>&amp; p) {</div>
<div class="line">     <span class="keyword">auto</span> dir = p.<a class="code" href="classime_1_1_property.html#a479983eb96ec875c444bb2da128545d6">getValue</a>&lt;<a class="code" href="classime_1_1_vector2.html">ime::Direction</a>&gt;();</div>
<div class="line">    <span class="comment">// Do something - Maybe rotate the game object in the new direction</span></div>
<div class="line">});</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>update </dd></dl>

</div>
</div>
<a id="a12cabfa262b6cc45d9ede24ed503d835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cabfa262b6cc45d9ede24ed503d835">&#9670;&nbsp;</a></span>setAdaptiveMoveEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::setAdaptiveMoveEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable adaptive movement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>True to enable, otherwise false</td></tr>
  </table>
  </dd>
</dl>
<p>This function affects how the target behaves when its current path to a destination tile is blocked by a solid tile or an obstacle.</p>
<p>When smart move is enabled, the target immediately attempts to find another path to its destination, in other words it can see ahead. When smart move is disabled the target will continue to move along the blocked path until it gets to the roadblock. Only then will it attempt to find another path</p>
<p>Note that if the grid is static, its advised to keep adaptive move disabled for performance reasons</p>
<p>By default, adaptive movement is disabled </p>

</div>
</div>
<a id="ae33ff1a4b05ebb6dd5e82975e3620772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33ff1a4b05ebb6dd5e82975e3620772">&#9670;&nbsp;</a></span>setDestination() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::setDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structime_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the index of the tile the target should go to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The targets new destination</td></tr>
  </table>
  </dd>
</dl>
<p>The specified index must be within the the bounds of the grid and the tile at index must be reachable from the targets current tile, otherwise, the target will not move, since it cannot establish a path to the destination </p>

</div>
</div>
<a id="a3a5c796207d09f91712324e097d28039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5c796207d09f91712324e097d28039">&#9670;&nbsp;</a></span>setDestination() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::setDestination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the position the target should go to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>New target position</td></tr>
  </table>
  </dd>
</dl>
<p>The specified position must be within the grid and the tile at that position must be reachable from the targets current tile, otherwise the target will not move since it cannot establish a path to the destination </p>

</div>
</div>
<a id="ad85c7ed906d77ea8509ef271707a2d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85c7ed906d77ea8509ef271707a2d2d">&#9670;&nbsp;</a></span>setMaxLinearSpeed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setMaxLinearSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceime.html#a4866528be676b7c7831fb843650a1065">Vector2f</a>&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum linear speed of the game object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">speed</td><td>The new maximum speed</td></tr>
  </table>
  </dd>
</dl>
<p>If the game object is currently moving, the speed will be set after it reaches its current target tile</p>
<dl class="section warning"><dt>Warning</dt><dd>When using a grid mover the velocity of the game object must not be set directly but rather through this function. Setting the velocity directly will transfer movement management of the game object from the grid mover to the physics engine </dd></dl>

</div>
</div>
<a id="a2a264750eeefd2cacf760ad9d785d3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a264750eeefd2cacf760ad9d785d3a7">&#9670;&nbsp;</a></span>setMovementFreeze()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setMovementFreeze </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>freeze</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Freeze or unfreeze the targets movement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freeze</td><td>True to freeze movement or false to unfreeze</td></tr>
  </table>
  </dd>
</dl>
<p>This function achieves the same thing as <a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b" title="Restrict the movement of the game object to certain directions.">setMovementRestriction()</a>. The difference is when the function is called while the target is moving. setMovementRestriction(true) will prevent the target from moving further after the targets gets to its targeted tile whilst setMovementFreeze(true) will immediately prevent the target from moving further. This means that the target can temporarily be in between grid tiles</p>
<p>By default, the targets movement is not frozen</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a121bf39232196e459b0c0b619e963c7b" title="Restrict the movement of the game object to certain directions.">setMovementRestriction</a> </dd></dl>

</div>
</div>
<a id="a121bf39232196e459b0c0b619e963c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121bf39232196e459b0c0b619e963c7b">&#9670;&nbsp;</a></span>setMovementRestriction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setMovementRestriction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_grid_mover.html#a62c372e0dbb8e5a0be9b8fa5fd9724fc">MoveRestriction</a>&#160;</td>
          <td class="paramname"><em>moveRestriction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restrict the movement of the game object to certain directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moveRestriction</td><td>Permitted direction of travel</td></tr>
  </table>
  </dd>
</dl>
<p>By default the movement restrictions is MovementRestriction::None</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_grid_mover.html#a2a264750eeefd2cacf760ad9d785d3a7" title="Freeze or unfreeze the targets movement.">setMovementFreeze</a> </dd></dl>

</div>
</div>
<a id="a48987d1e2fe8c55b07e45726d3c92e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48987d1e2fe8c55b07e45726d3c92e54">&#9670;&nbsp;</a></span>setPathFinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::setPathFinder </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classime_1_1_i_path_finder_strategy.html">IPathFinderStrategy</a> &gt;&#160;</td>
          <td class="paramname"><em>pathFinder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the path finder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pathFinder</td><td>New path finder</td></tr>
  </table>
  </dd>
</dl>
<p>The default path finder is Breadth First Search </p>

</div>
</div>
<a id="a8a77cd910f82fa19210873cc2f43f152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a77cd910f82fa19210873cc2f43f152">&#9670;&nbsp;</a></span>setPathViewEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::setPathViewEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether or not the targets path should be shown or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">showPath</td><td>True to show path, otherwise false</td></tr>
  </table>
  </dd>
</dl>
<p>By default, the path is not shown </p>

</div>
</div>
<a id="aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3c3b9d74f3f5d26f1eb9ad2e8dbc1c">&#9670;&nbsp;</a></span>setTag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::Object::setTag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign the object an alias. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The alias of the object</td></tr>
  </table>
  </dd>
</dl>
<p>This function is useful if you want to refer to the object by a tag instead of its object id. Unlike an object id, multiple objects may have the same tag</p>
<p>By default, the tag is an empty string</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_object.html#ac2e9c8f45f13c68e129775bc058231af" title="Get the unique id of the object.">getObjectId</a> </dd></dl>

</div>
</div>
<a id="ae038f99785bbdb2b08ac608734386d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae038f99785bbdb2b08ac608734386d05">&#9670;&nbsp;</a></span>setTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::setTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classime_1_1_game_object.html">GameObject</a> *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the controlled entity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>New target</td></tr>
  </table>
  </dd>
</dl>
<p>Provide nullptr as argument to remove current target</p>
<dl class="section warning"><dt>Warning</dt><dd>if the <em>target</em> is not a <em>nullptr</em>, then it must exist in the grid and have a rigid Body of time Body::Type::Kinematic attached to it prior to function call </dd></dl>

</div>
</div>
<a id="acf9d65dd47d96148be35af6e615b2cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9d65dd47d96148be35af6e615b2cda">&#9670;&nbsp;</a></span>startMovement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::startMovement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start moving the target to its destination tile. </p>
<p>This function has no effect if the targets movement is not stopped</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_target_grid_mover.html#a09b339c8b28d83ab65247aab40570d06" title="Stop the targets movement.">stopMovement</a> </dd></dl>

</div>
</div>
<a id="a09b339c8b28d83ab65247aab40570d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b339c8b28d83ab65247aab40570d06">&#9670;&nbsp;</a></span>stopMovement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ime::TargetGridMover::stopMovement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the targets movement. </p>
<p>Since a child in the grid can never be in between tiles, the targets movement will be stopped after it completes its current move. The targets movement is stopped by default</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classime_1_1_target_grid_mover.html#acf9d65dd47d96148be35af6e615b2cda" title="Start moving the target to its destination tile.">startMovement</a> </dd></dl>

</div>
</div>
<a id="a1861b96d89d9bc4539eda2cdacd356b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1861b96d89d9bc4539eda2cdacd356b8">&#9670;&nbsp;</a></span>teleportTargetToDestination()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ime::GridMover::teleportTargetToDestination </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force the target to reach it's destination. </p>
<p>The destination in this context is always the adjacent tile the target is headed towards. This function has no effect if the target is not moving towards any tile </p>

</div>
</div>
<a id="a80d24db78b5837e3cbacf4ddcea2bffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d24db78b5837e3cbacf4ddcea2bffd">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::Object::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an event listener from an event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The name of the event to remove an event listener from </td></tr>
    <tr><td class="paramname">id</td><td>The unique id of the event listener to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the event listener was removed or false if the event or the event listener is does not exist</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Display the tag of the object to console every time it changes</span></div>
<div class="line"><span class="keyword">auto</span> tagChangeId = <span class="keywordtype">object</span>.onPropertyChange(<span class="stringliteral">&quot;tag&quot;</span>, [](<a class="code" href="classime_1_1_property.html">ime::Property</a> tag) {</div>
<div class="line">     std::cout &lt;&lt; name.getValue&lt;std::string&gt;() &lt;&lt; std::endl;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Stop displaying the tag of the object when it changes</span></div>
<div class="line"><span class="keywordtype">object</span>.unsubscribe(<span class="stringliteral">&quot;tag&quot;</span>, tagChangeId);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac2fb43eb9a13ec364398d86b77e0a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fb43eb9a13ec364398d86b77e0a23a">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ime::GridMover::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>handlerId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an event listener from the grid movers event list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handlerId</td><td>The unique identification number of the listener </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the event listener was removed or false if no such listener exist in the grid movers event list </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_target_grid_mover_8h_source.html">TargetGridMover.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassime_1_1_property_html"><div class="ttname"><a href="classime_1_1_property.html">ime::Property</a></div><div class="ttdoc">Class that can store a value of any type.</div><div class="ttdef"><b>Definition:</b> <a href="_property_8h_source.html#l00036">Property.h:36</a></div></div>
<div class="ttc" id="aclassime_1_1_vector2_html"><div class="ttname"><a href="classime_1_1_vector2.html">ime::Vector2</a></div><div class="ttdoc">2D vector</div><div class="ttdef"><b>Definition:</b> <a href="_vector2_8h_source.html#l00035">Vector2.h:35</a></div></div>
<div class="ttc" id="aclassime_1_1_property_html_a479983eb96ec875c444bb2da128545d6"><div class="ttname"><a href="classime_1_1_property.html#a479983eb96ec875c444bb2da128545d6">ime::Property::getValue</a></div><div class="ttdeci">T getValue() const</div><div class="ttdoc">Get the value of the property.</div></div>
        </div>
        <div id="footer-container">
            <div id="footer">
                IME is licensed under the terms and conditions of the <a href="https://github.com/KwenaMashamaite/IME/blob/master/LICENSE">MIT license</a>.<br>
                Copyright &copy; 2020-2021 Kwena Mashamaite
            </div>
        </div>
    </body>
</html>
